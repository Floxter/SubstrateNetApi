{
  "Origin": "wss://mogiway-01.dotmog.com",
  "Magic": "meta",
  "Version": "v12",
  "Modules": [
    {
      "Name": "System",
      "Index": 0,
      "Storage": {
        "Prefix": "System",
        "Items": [
          {
            "Name": "Account",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "AccountInfo<T::Index, T::AccountData>",
              "IsLinked": false
            },
            "FallBack": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " The full account information for a particular account ID."
            ]
          },
          {
            "Name": "ExtrinsicCount",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Total extrinsics count for the current block."
            ]
          },
          {
            "Name": "BlockWeight",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "ConsumedWeight",
              "IsLinked": false
            },
            "FallBack": "0x000000000000000000000000000000000000000000000000",
            "Documentations": [
              " The current weight for the block."
            ]
          },
          {
            "Name": "AllExtrinsicsLen",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Total length (in bytes) for all extrinsics put together, for the current block."
            ]
          },
          {
            "Name": "BlockHash",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::BlockNumber",
              "Key2": null,
              "Value": "T::Hash",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " Map of block numbers to block hashes."
            ]
          },
          {
            "Name": "ExtrinsicData",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "u32",
              "Key2": null,
              "Value": "Vec<u8>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Extrinsics data for the current block (maps an extrinsic's index to its data)."
            ]
          },
          {
            "Name": "Number",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::BlockNumber",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " The current block number being processed. Set by `execute_block`."
            ]
          },
          {
            "Name": "ParentHash",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::Hash",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " Hash of the previous block."
            ]
          },
          {
            "Name": "Digest",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "DigestOf<T>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Digest of the current block, also part of the block header."
            ]
          },
          {
            "Name": "Events",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<EventRecord<T::Event, T::Hash>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Events deposited for the current block."
            ]
          },
          {
            "Name": "EventCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "EventIndex",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " The number of events in the `Events<T>` list."
            ]
          },
          {
            "Name": "EventTopics",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "Vec<(T::BlockNumber, EventIndex)>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Mapping between a topic (represented by T::Hash) and a vector of indexes",
              " of events in the `<Events<T>>` list.",
              "",
              " All topic vectors have deterministic storage locations depending on the topic. This",
              " allows light-clients to leverage the changes trie storage tracking mechanism and",
              " in case of changes fetch the list of events of interest.",
              "",
              " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just",
              " the `EventIndex` then in case if the topic has the same contents on the next block",
              " no notification will be triggered thus the event might be lost."
            ]
          },
          {
            "Name": "LastRuntimeUpgrade",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "LastRuntimeUpgradeInfo",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."
            ]
          },
          {
            "Name": "UpgradedToU32RefCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "bool",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."
            ]
          },
          {
            "Name": "UpgradedToDualRefCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "bool",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " True if we have upgraded so that AccountInfo contains two types of `RefCount`. False",
              " (default) if not."
            ]
          },
          {
            "Name": "ExecutionPhase",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Phase",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The execution phase of the block."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "fill_block",
          "Arguments": [
            {
              "Name": "_ratio",
              "Type": "Perbill"
            }
          ],
          "Documentations": [
            " A dispatch that will fill the block weight up to the given ratio."
          ]
        },
        {
          "Name": "remark",
          "Arguments": [
            {
              "Name": "_remark",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Make some on-chain remark.",
            "",
            " # <weight>",
            " - `O(1)`",
            " - Base Weight: 0.665 Âµs, independent of remark length.",
            " - No DB operations.",
            " # </weight>"
          ]
        },
        {
          "Name": "set_heap_pages",
          "Arguments": [
            {
              "Name": "pages",
              "Type": "u64"
            }
          ],
          "Documentations": [
            " Set the number of pages in the WebAssembly environment's heap.",
            "",
            " # <weight>",
            " - `O(1)`",
            " - 1 storage write.",
            " - Base Weight: 1.405 Âµs",
            " - 1 write to HEAP_PAGES",
            " # </weight>"
          ]
        },
        {
          "Name": "set_code",
          "Arguments": [
            {
              "Name": "code",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Set the new runtime code.",
            "",
            " # <weight>",
            " - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`",
            " - 1 storage write (codec `O(C)`).",
            " - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).",
            " - 1 event.",
            " The weight of this function is dependent on the runtime, but generally this is very expensive.",
            " We will treat this as a full block.",
            " # </weight>"
          ]
        },
        {
          "Name": "set_code_without_checks",
          "Arguments": [
            {
              "Name": "code",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Set the new runtime code without doing any checks of the given `code`.",
            "",
            " # <weight>",
            " - `O(C)` where `C` length of `code`",
            " - 1 storage write (codec `O(C)`).",
            " - 1 event.",
            " The weight of this function is dependent on the runtime. We will treat this as a full block.",
            " # </weight>"
          ]
        },
        {
          "Name": "set_changes_trie_config",
          "Arguments": [
            {
              "Name": "changes_trie_config",
              "Type": "Option<ChangesTrieConfiguration>"
            }
          ],
          "Documentations": [
            " Set the new changes trie configuration.",
            "",
            " # <weight>",
            " - `O(1)`",
            " - 1 storage write or delete (codec `O(1)`).",
            " - 1 call to `deposit_log`: Uses `append` API, so O(1)",
            " - Base Weight: 7.218 Âµs",
            " - DB Weight:",
            "     - Writes: Changes Trie, System Digest",
            " # </weight>"
          ]
        },
        {
          "Name": "set_storage",
          "Arguments": [
            {
              "Name": "items",
              "Type": "Vec<KeyValue>"
            }
          ],
          "Documentations": [
            " Set some items of storage.",
            "",
            " # <weight>",
            " - `O(I)` where `I` length of `items`",
            " - `I` storage writes (`O(1)`).",
            " - Base Weight: 0.568 * i Âµs",
            " - Writes: Number of items",
            " # </weight>"
          ]
        },
        {
          "Name": "kill_storage",
          "Arguments": [
            {
              "Name": "keys",
              "Type": "Vec<Key>"
            }
          ],
          "Documentations": [
            " Kill some items from storage.",
            "",
            " # <weight>",
            " - `O(IK)` where `I` length of `keys` and `K` length of one key",
            " - `I` storage deletions.",
            " - Base Weight: .378 * i Âµs",
            " - Writes: Number of items",
            " # </weight>"
          ]
        },
        {
          "Name": "kill_prefix",
          "Arguments": [
            {
              "Name": "prefix",
              "Type": "Key"
            },
            {
              "Name": "_subkeys",
              "Type": "u32"
            }
          ],
          "Documentations": [
            " Kill all storage items with a key that starts with the given prefix.",
            "",
            " **NOTE:** We rely on the Root origin to provide us the number of subkeys under",
            " the prefix we are removing to accurately calculate the weight of this function.",
            "",
            " # <weight>",
            " - `O(P)` where `P` amount of keys with prefix `prefix`",
            " - `P` storage deletions.",
            " - Base Weight: 0.834 * P Âµs",
            " - Writes: Number of subkeys + 1",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " An extrinsic completed successfully. \\[info\\]"
          ],
          "Name": "ExtrinsicSuccess",
          "EventArgs": [
            "DispatchInfo"
          ]
        },
        {
          "Documentations": [
            " An extrinsic failed. \\[error, info\\]"
          ],
          "Name": "ExtrinsicFailed",
          "EventArgs": [
            "DispatchError",
            "DispatchInfo"
          ]
        },
        {
          "Documentations": [
            " `:code` was updated."
          ],
          "Name": "CodeUpdated",
          "EventArgs": [

          ]
        },
        {
          "Documentations": [
            " A new \\[account\\] was created."
          ],
          "Name": "NewAccount",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " An \\[account\\] was reaped."
          ],
          "Name": "KilledAccount",
          "EventArgs": [
            "AccountId"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "BlockWeights",
          "Type": "limits::BlockWeights",
          "Value": "0x00F2052A0100000000204AA9D1010000405973070000000001C06E96A62E010000010098F73E5D010000010000000000000000405973070000000001C0F6E810A30100000100204AA9D1010000010088526A740000004059730700000000000000",
          "Documentations": [
            " Block & extrinsics weights: base values and limits."
          ]
        },
        {
          "Name": "BlockLength",
          "Type": "limits::BlockLength",
          "Value": "0x00003C000000500000005000",
          "Documentations": [
            " The maximum length of a block (in bytes)."
          ]
        },
        {
          "Name": "BlockHashCount",
          "Type": "T::BlockNumber",
          "Value": "0x60090000",
          "Documentations": [
            " Maximum number of block number to block hash mappings to keep (oldest pruned first)."
          ]
        },
        {
          "Name": "DbWeight",
          "Type": "RuntimeDbWeight",
          "Value": "0x40787D010000000000E1F50500000000",
          "Documentations": [
            " The weight of runtime database operations the runtime can invoke."
          ]
        },
        {
          "Name": "Version",
          "Type": "RuntimeVersion",
          "Value": "0x2C646F746D6F672D6E6F6465206D696C6B797761790A000000050000000000000030DF6ACB689907609B0300000037E397FC7C91F5E40100000040FE3AD401F8959A04000000D2BC9897EED08F1502000000F78B278BE53F454C02000000ED99C5ACB25EEDF502000000CBCA25E39F14238702000000687AD44AD37F03C201000000BC9D89904F5B923F0100000068B66BA122C93FA70100000037C8BB1350A9A2A801000000AB3C0572291FEB8B0100000002000000",
          "Documentations": [
            " Get the chain's current version."
          ]
        },
        {
          "Name": "SS58Prefix",
          "Type": "u8",
          "Value": "0x2A",
          "Documentations": [
            " The designated SS85 prefix of this chain.",
            "",
            " This replaces the \"ss58Format\" property declared in the chain spec. Reason is",
            " that the runtime should know about the prefix in order to make use of it as",
            " an identifier of the chain."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " The name of specification does not match between the current runtime",
            " and the new runtime."
          ],
          "Name": "InvalidSpecName"
        },
        {
          "Documentations": [
            " The specification version is not allowed to decrease between the current runtime",
            " and the new runtime."
          ],
          "Name": "SpecVersionNeedsToIncrease"
        },
        {
          "Documentations": [
            " Failed to extract the runtime version from the new runtime.",
            "",
            " Either calling `Core_version` or decoding `RuntimeVersion` failed."
          ],
          "Name": "FailedToExtractRuntimeVersion"
        },
        {
          "Documentations": [
            " Suicide called when the account has non-default composite data."
          ],
          "Name": "NonDefaultComposite"
        },
        {
          "Documentations": [
            " There is a non-zero reference count preventing the account from being purged."
          ],
          "Name": "NonZeroRefCount"
        }
      ]
    },
    {
      "Name": "RandomnessCollectiveFlip",
      "Index": 1,
      "Storage": {
        "Prefix": "RandomnessCollectiveFlip",
        "Items": [
          {
            "Name": "RandomMaterial",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::Hash>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Series of block headers from the last 81 blocks that acts as random seed material. This",
              " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of",
              " the oldest hash."
            ]
          }
        ]
      },
      "Calls": [

      ],
      "Events": null,
      "Consts": [

      ],
      "Errors": [

      ]
    },
    {
      "Name": "Scheduler",
      "Index": 2,
      "Storage": {
        "Prefix": "Scheduler",
        "Items": [
          {
            "Name": "Agenda",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::BlockNumber",
              "Key2": null,
              "Value": "Vec<Option<Scheduled<<T as Config>::Call, T::BlockNumber, T::\nPalletsOrigin, T::AccountId>>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Items to be executed, indexed by the block number that they should be executed on."
            ]
          },
          {
            "Name": "Lookup",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "Vec<u8>",
              "Key2": null,
              "Value": "TaskAddress<T::BlockNumber>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Lookup from identity to the block number and index of the task."
            ]
          },
          {
            "Name": "StorageVersion",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Releases",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Storage version of the pallet.",
              "",
              " New networks start with last version."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "schedule",
          "Arguments": [
            {
              "Name": "when",
              "Type": "T::BlockNumber"
            },
            {
              "Name": "maybe_periodic",
              "Type": "Option<schedule::Period<T::BlockNumber>>"
            },
            {
              "Name": "priority",
              "Type": "schedule::Priority"
            },
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Anonymously schedule a task.",
            "",
            " # <weight>",
            " - S = Number of already scheduled calls",
            " - Base Weight: 22.29 + .126 * S Âµs",
            " - DB Weight:",
            "     - Read: Agenda",
            "     - Write: Agenda",
            " - Will use base weight of 25 which should be good for up to 30 scheduled calls",
            " # </weight>"
          ]
        },
        {
          "Name": "cancel",
          "Arguments": [
            {
              "Name": "when",
              "Type": "T::BlockNumber"
            },
            {
              "Name": "index",
              "Type": "u32"
            }
          ],
          "Documentations": [
            " Cancel an anonymously scheduled task.",
            "",
            " # <weight>",
            " - S = Number of already scheduled calls",
            " - Base Weight: 22.15 + 2.869 * S Âµs",
            " - DB Weight:",
            "     - Read: Agenda",
            "     - Write: Agenda, Lookup",
            " - Will use base weight of 100 which should be good for up to 30 scheduled calls",
            " # </weight>"
          ]
        },
        {
          "Name": "schedule_named",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Vec<u8>"
            },
            {
              "Name": "when",
              "Type": "T::BlockNumber"
            },
            {
              "Name": "maybe_periodic",
              "Type": "Option<schedule::Period<T::BlockNumber>>"
            },
            {
              "Name": "priority",
              "Type": "schedule::Priority"
            },
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Schedule a named task.",
            "",
            " # <weight>",
            " - S = Number of already scheduled calls",
            " - Base Weight: 29.6 + .159 * S Âµs",
            " - DB Weight:",
            "     - Read: Agenda, Lookup",
            "     - Write: Agenda, Lookup",
            " - Will use base weight of 35 which should be good for more than 30 scheduled calls",
            " # </weight>"
          ]
        },
        {
          "Name": "cancel_named",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Cancel a named scheduled task.",
            "",
            " # <weight>",
            " - S = Number of already scheduled calls",
            " - Base Weight: 24.91 + 2.907 * S Âµs",
            " - DB Weight:",
            "     - Read: Agenda, Lookup",
            "     - Write: Agenda, Lookup",
            " - Will use base weight of 100 which should be good for up to 30 scheduled calls",
            " # </weight>"
          ]
        },
        {
          "Name": "schedule_after",
          "Arguments": [
            {
              "Name": "after",
              "Type": "T::BlockNumber"
            },
            {
              "Name": "maybe_periodic",
              "Type": "Option<schedule::Period<T::BlockNumber>>"
            },
            {
              "Name": "priority",
              "Type": "schedule::Priority"
            },
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Anonymously schedule a task after a delay.",
            "",
            " # <weight>",
            " Same as [`schedule`].",
            " # </weight>"
          ]
        },
        {
          "Name": "schedule_named_after",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Vec<u8>"
            },
            {
              "Name": "after",
              "Type": "T::BlockNumber"
            },
            {
              "Name": "maybe_periodic",
              "Type": "Option<schedule::Period<T::BlockNumber>>"
            },
            {
              "Name": "priority",
              "Type": "schedule::Priority"
            },
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Schedule a named task after a delay.",
            "",
            " # <weight>",
            " Same as [`schedule_named`].",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " Scheduled some task. \\[when, index\\]"
          ],
          "Name": "Scheduled",
          "EventArgs": [
            "BlockNumber",
            "u32"
          ]
        },
        {
          "Documentations": [
            " Canceled some task. \\[when, index\\]"
          ],
          "Name": "Canceled",
          "EventArgs": [
            "BlockNumber",
            "u32"
          ]
        },
        {
          "Documentations": [
            " Dispatched some task. \\[task, id, result\\]"
          ],
          "Name": "Dispatched",
          "EventArgs": [
            "TaskAddress<BlockNumber>",
            "Option<Vec<u8>>",
            "DispatchResult"
          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [
        {
          "Documentations": [
            " Failed to schedule a call"
          ],
          "Name": "FailedToSchedule"
        },
        {
          "Documentations": [
            " Cannot find the scheduled call."
          ],
          "Name": "NotFound"
        },
        {
          "Documentations": [
            " Given target block number is in the past."
          ],
          "Name": "TargetBlockNumberInPast"
        },
        {
          "Documentations": [
            " Reschedule failed because it does not change scheduled time."
          ],
          "Name": "RescheduleNoChange"
        }
      ]
    },
    {
      "Name": "Babe",
      "Index": 3,
      "Storage": {
        "Prefix": "Babe",
        "Items": [
          {
            "Name": "EpochIndex",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u64",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " Current epoch index."
            ]
          },
          {
            "Name": "Authorities",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<(AuthorityId, BabeAuthorityWeight)>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Current epoch authorities."
            ]
          },
          {
            "Name": "GenesisSlot",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Slot",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " The slot at which the first epoch actually started. This is 0",
              " until the first block of the chain."
            ]
          },
          {
            "Name": "CurrentSlot",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Slot",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " Current slot number."
            ]
          },
          {
            "Name": "Randomness",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "schnorrkel::Randomness",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " The epoch randomness for the *current* epoch.",
              "",
              " # Security",
              "",
              " This MUST NOT be used for gambling, as it can be influenced by a",
              " malicious validator in the short term. It MAY be used in many",
              " cryptographic protocols, however, so long as one remembers that this",
              " (like everything else on-chain) it is public. For example, it can be",
              " used where a number is needed that cannot have been chosen by an",
              " adversary, for purposes such as public-coin zero-knowledge proofs."
            ]
          },
          {
            "Name": "NextEpochConfig",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "NextConfigDescriptor",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Next epoch configuration, if changed."
            ]
          },
          {
            "Name": "NextRandomness",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "schnorrkel::Randomness",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " Next epoch randomness."
            ]
          },
          {
            "Name": "NextAuthorities",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<(AuthorityId, BabeAuthorityWeight)>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Next epoch authorities."
            ]
          },
          {
            "Name": "SegmentIndex",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " Randomness under construction.",
              "",
              " We make a tradeoff between storage accesses and list length.",
              " We store the under-construction randomness in segments of up to",
              " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.",
              "",
              " Once a segment reaches this length, we begin the next one.",
              " We reset all segments and return to `0` at the beginning of every",
              " epoch."
            ]
          },
          {
            "Name": "UnderConstruction",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "u32",
              "Key2": null,
              "Value": "Vec<schnorrkel::Randomness>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."
            ]
          },
          {
            "Name": "Initialized",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "MaybeRandomness",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Temporary value (cleared at block finalization) which is `Some`",
              " if per-block initialization has already been called for current block."
            ]
          },
          {
            "Name": "AuthorVrfRandomness",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "MaybeRandomness",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Temporary value (cleared at block finalization) that includes the VRF output generated",
              " at this block. This field should always be populated during block processing unless",
              " secondary plain slots are enabled (which don't contain a VRF output)."
            ]
          },
          {
            "Name": "Lateness",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::BlockNumber",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " How late the current block is compared to its parent.",
              "",
              " This entry is populated as part of block execution and is cleaned up",
              " on block finalization. Querying this storage entry outside of block",
              " execution context should always yield zero."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "report_equivocation",
          "Arguments": [
            {
              "Name": "equivocation_proof",
              "Type": "EquivocationProof<T::Header>"
            },
            {
              "Name": "key_owner_proof",
              "Type": "T::KeyOwnerProof"
            }
          ],
          "Documentations": [
            " Report authority equivocation/misbehavior. This method will verify",
            " the equivocation proof and validate the given key ownership proof",
            " against the extracted offender. If both are valid, the offence will",
            " be reported."
          ]
        },
        {
          "Name": "report_equivocation_unsigned",
          "Arguments": [
            {
              "Name": "equivocation_proof",
              "Type": "EquivocationProof<T::Header>"
            },
            {
              "Name": "key_owner_proof",
              "Type": "T::KeyOwnerProof"
            }
          ],
          "Documentations": [
            " Report authority equivocation/misbehavior. This method will verify",
            " the equivocation proof and validate the given key ownership proof",
            " against the extracted offender. If both are valid, the offence will",
            " be reported.",
            " This extrinsic must be called unsigned and it is expected that only",
            " block authors will call it (validated in `ValidateUnsigned`), as such",
            " if the block author is defined it will be defined as the equivocation",
            " reporter."
          ]
        }
      ],
      "Events": null,
      "Consts": [
        {
          "Name": "EpochDuration",
          "Type": "u64",
          "Value": "0xC800000000000000",
          "Documentations": [
            " The number of **slots** that an epoch takes. We couple sessions to",
            " epochs, i.e. we start a new session once the new epoch begins.",
            " NOTE: Currently it is not possible to change the epoch duration",
            " after the chain has started. Attempting to do so will brick block",
            " production."
          ]
        },
        {
          "Name": "ExpectedBlockTime",
          "Type": "T::Moment",
          "Value": "0xB80B000000000000",
          "Documentations": [
            " The expected average block time at which BABE should be creating",
            " blocks. Since BABE is probabilistic it is not trivial to figure out",
            " what the expected average block time should be based on the slot",
            " duration and the security parameter `c` (where `1 - c` represents",
            " the probability of a slot being empty)."
          ]
        }
      ],
      "Errors": [

      ]
    },
    {
      "Name": "Timestamp",
      "Index": 4,
      "Storage": {
        "Prefix": "Timestamp",
        "Items": [
          {
            "Name": "Now",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::Moment",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " Current time for the current block."
            ]
          },
          {
            "Name": "DidUpdate",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "bool",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Did the timestamp get updated in this block?"
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "set",
          "Arguments": [
            {
              "Name": "now",
              "Type": "Compact<T::Moment>"
            }
          ],
          "Documentations": [
            " Set the current time.",
            "",
            " This call should be invoked exactly once per block. It will panic at the finalization",
            " phase, if this call hasn't been invoked by that time.",
            "",
            " The timestamp should be greater than the previous one by the amount specified by",
            " `MinimumPeriod`.",
            "",
            " The dispatch origin for this call must be `Inherent`.",
            "",
            " # <weight>",
            " - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)",
            " - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)",
            " - 1 event handler `on_timestamp_set`. Must be `O(1)`.",
            " # </weight>"
          ]
        }
      ],
      "Events": null,
      "Consts": [
        {
          "Name": "MinimumPeriod",
          "Type": "T::Moment",
          "Value": "0xDC05000000000000",
          "Documentations": [
            " The minimum period between blocks. Beware that this is different to the *expected* period",
            " that the block production apparatus provides. Your chosen consensus system will generally",
            " work with this to determine a sensible block time. e.g. For Aura, it will be double this",
            " period on default settings."
          ]
        }
      ],
      "Errors": [

      ]
    },
    {
      "Name": "Indices",
      "Index": 5,
      "Storage": {
        "Prefix": "Indices",
        "Items": [
          {
            "Name": "Accounts",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AccountIndex",
              "Key2": null,
              "Value": "(T::AccountId, BalanceOf<T>, bool)",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The lookup from index to account."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "claim",
          "Arguments": [
            {
              "Name": "index",
              "Type": "T::AccountIndex"
            }
          ],
          "Documentations": [
            " Assign an previously unassigned index.",
            "",
            " Payment: `Deposit` is reserved from the sender account.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `index`: the index to be claimed. This must not be in use.",
            "",
            " Emits `IndexAssigned` if successful.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - One storage mutation (codec `O(1)`).",
            " - One reserve operation.",
            " - One event.",
            " -------------------",
            " - DB Weight: 1 Read/Write (Accounts)",
            " # </weight>"
          ]
        },
        {
          "Name": "transfer",
          "Arguments": [
            {
              "Name": "new",
              "Type": "T::AccountId"
            },
            {
              "Name": "index",
              "Type": "T::AccountIndex"
            }
          ],
          "Documentations": [
            " Assign an index already owned by the sender to another account. The balance reservation",
            " is effectively transferred to the new account.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `index`: the index to be re-assigned. This must be owned by the sender.",
            " - `new`: the new owner of the index. This function is a no-op if it is equal to sender.",
            "",
            " Emits `IndexAssigned` if successful.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - One storage mutation (codec `O(1)`).",
            " - One transfer operation.",
            " - One event.",
            " -------------------",
            " - DB Weight:",
            "    - Reads: Indices Accounts, System Account (recipient)",
            "    - Writes: Indices Accounts, System Account (recipient)",
            " # </weight>"
          ]
        },
        {
          "Name": "free",
          "Arguments": [
            {
              "Name": "index",
              "Type": "T::AccountIndex"
            }
          ],
          "Documentations": [
            " Free up an index owned by the sender.",
            "",
            " Payment: Any previous deposit placed for the index is unreserved in the sender account.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must own the index.",
            "",
            " - `index`: the index to be freed. This must be owned by the sender.",
            "",
            " Emits `IndexFreed` if successful.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - One storage mutation (codec `O(1)`).",
            " - One reserve operation.",
            " - One event.",
            " -------------------",
            " - DB Weight: 1 Read/Write (Accounts)",
            " # </weight>"
          ]
        },
        {
          "Name": "force_transfer",
          "Arguments": [
            {
              "Name": "new",
              "Type": "T::AccountId"
            },
            {
              "Name": "index",
              "Type": "T::AccountIndex"
            },
            {
              "Name": "freeze",
              "Type": "bool"
            }
          ],
          "Documentations": [
            " Force an index to an account. This doesn't require a deposit. If the index is already",
            " held, then any deposit is reimbursed to its current owner.",
            "",
            " The dispatch origin for this call must be _Root_.",
            "",
            " - `index`: the index to be (re-)assigned.",
            " - `new`: the new owner of the index. This function is a no-op if it is equal to sender.",
            " - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.",
            "",
            " Emits `IndexAssigned` if successful.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - One storage mutation (codec `O(1)`).",
            " - Up to one reserve operation.",
            " - One event.",
            " -------------------",
            " - DB Weight:",
            "    - Reads: Indices Accounts, System Account (original owner)",
            "    - Writes: Indices Accounts, System Account (original owner)",
            " # </weight>"
          ]
        },
        {
          "Name": "freeze",
          "Arguments": [
            {
              "Name": "index",
              "Type": "T::AccountIndex"
            }
          ],
          "Documentations": [
            " Freeze an index so it will always point to the sender account. This consumes the deposit.",
            "",
            " The dispatch origin for this call must be _Signed_ and the signing account must have a",
            " non-frozen account `index`.",
            "",
            " - `index`: the index to be frozen in place.",
            "",
            " Emits `IndexFrozen` if successful.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - One storage mutation (codec `O(1)`).",
            " - Up to one slash operation.",
            " - One event.",
            " -------------------",
            " - DB Weight: 1 Read/Write (Accounts)",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A account index was assigned. \\[index, who\\]"
          ],
          "Name": "IndexAssigned",
          "EventArgs": [
            "AccountId",
            "AccountIndex"
          ]
        },
        {
          "Documentations": [
            " A account index has been freed up (unassigned). \\[index\\]"
          ],
          "Name": "IndexFreed",
          "EventArgs": [
            "AccountIndex"
          ]
        },
        {
          "Documentations": [
            " A account index has been frozen to its current account ID. \\[index, who\\]"
          ],
          "Name": "IndexFrozen",
          "EventArgs": [
            "AccountIndex",
            "AccountId"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "Deposit",
          "Type": "BalanceOf<T>",
          "Value": "0x00407A10F35A00000000000000000000",
          "Documentations": [
            " The deposit needed for reserving an index."
          ]
        }
      ],
      "Errors": [

      ]
    },
    {
      "Name": "Balances",
      "Index": 6,
      "Storage": {
        "Prefix": "Balances",
        "Items": [
          {
            "Name": "TotalIssuance",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::Balance",
              "IsLinked": false
            },
            "FallBack": "0x00000000000000000000000000000000",
            "Documentations": [
              " The total units issued in the system."
            ]
          },
          {
            "Name": "Account",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "AccountData<T::Balance>",
              "IsLinked": false
            },
            "FallBack": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " The balance of an account.",
              "",
              " NOTE: This is only used in the case that this pallet is used to store balances."
            ]
          },
          {
            "Name": "Locks",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "Vec<BalanceLock<T::Balance>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Any liquidity locks on some account balances.",
              " NOTE: Should only be accessed when setting, changing and freeing a lock."
            ]
          },
          {
            "Name": "StorageVersion",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Releases",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Storage version of the pallet.",
              "",
              " This is set to v2.0.0 for new networks."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "transfer",
          "Arguments": [
            {
              "Name": "dest",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "value",
              "Type": "Compact<T::Balance>"
            }
          ],
          "Documentations": [
            " Transfer some liquid free balance to another account.",
            "",
            " `transfer` will set the `FreeBalance` of the sender and receiver.",
            " It will decrease the total issuance of the system by the `TransferFee`.",
            " If the sender's account is below the existential deposit as a result",
            " of the transfer, the account will be reaped.",
            "",
            " The dispatch origin for this call must be `Signed` by the transactor.",
            "",
            " # <weight>",
            " - Dependent on arguments but not critical, given proper implementations for",
            "   input config types. See related functions below.",
            " - It contains a limited number of reads and writes internally and no complex computation.",
            "",
            " Related functions:",
            "",
            "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.",
            "   - Transferring balances to accounts that did not exist before will cause",
            "      `T::OnNewAccount::on_new_account` to be called.",
            "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.",
            "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional",
            "     check that the transfer will not kill the origin account.",
            " ---------------------------------",
            " - Base Weight: 73.64 Âµs, worst case scenario (account created, account removed)",
            " - DB Weight: 1 Read and 1 Write to destination account",
            " - Origin account is already in memory, so no DB operations for them.",
            " # </weight>"
          ]
        },
        {
          "Name": "set_balance",
          "Arguments": [
            {
              "Name": "who",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "new_free",
              "Type": "Compact<T::Balance>"
            },
            {
              "Name": "new_reserved",
              "Type": "Compact<T::Balance>"
            }
          ],
          "Documentations": [
            " Set the balances of a given account.",
            "",
            " This will alter `FreeBalance` and `ReservedBalance` in storage. it will",
            " also decrease the total issuance of the system (`TotalIssuance`).",
            " If the new free or reserved balance is below the existential deposit,",
            " it will reset the account nonce (`frame_system::AccountNonce`).",
            "",
            " The dispatch origin for this call is `root`.",
            "",
            " # <weight>",
            " - Independent of the arguments.",
            " - Contains a limited number of reads and writes.",
            " ---------------------",
            " - Base Weight:",
            "     - Creating: 27.56 Âµs",
            "     - Killing: 35.11 Âµs",
            " - DB Weight: 1 Read, 1 Write to `who`",
            " # </weight>"
          ]
        },
        {
          "Name": "force_transfer",
          "Arguments": [
            {
              "Name": "source",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "dest",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "value",
              "Type": "Compact<T::Balance>"
            }
          ],
          "Documentations": [
            " Exactly as `transfer`, except the origin must be root and the source account may be",
            " specified.",
            " # <weight>",
            " - Same as transfer, but additional read and write because the source account is",
            "   not assumed to be in the overlay.",
            " # </weight>"
          ]
        },
        {
          "Name": "transfer_keep_alive",
          "Arguments": [
            {
              "Name": "dest",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "value",
              "Type": "Compact<T::Balance>"
            }
          ],
          "Documentations": [
            " Same as the [`transfer`] call, but with a check that the transfer will not kill the",
            " origin account.",
            "",
            " 99% of the time you want [`transfer`] instead.",
            "",
            " [`transfer`]: struct.Pallet.html#method.transfer",
            " # <weight>",
            " - Cheaper than transfer because account cannot be killed.",
            " - Base Weight: 51.4 Âµs",
            " - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)",
            " #</weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " An account was created with some free balance. \\[account, free_balance\\]"
          ],
          "Name": "Endowed",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " An account was removed whose balance was non-zero but below ExistentialDeposit,",
            " resulting in an outright loss. \\[account, balance\\]"
          ],
          "Name": "DustLost",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Transfer succeeded. \\[from, to, value\\]"
          ],
          "Name": "Transfer",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A balance was set by root. \\[who, free, reserved\\]"
          ],
          "Name": "BalanceSet",
          "EventArgs": [
            "AccountId",
            "Balance",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Some amount was deposited (e.g. for transaction fees). \\[who, deposit\\]"
          ],
          "Name": "Deposit",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Some balance was reserved (moved from free to reserved). \\[who, value\\]"
          ],
          "Name": "Reserved",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Some balance was unreserved (moved from reserved to free). \\[who, value\\]"
          ],
          "Name": "Unreserved",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Some balance was moved from the reserve of the first account to the second account.",
            " Final argument indicates the destination balance type.",
            " \\[from, to, balance, destination_status\\]"
          ],
          "Name": "ReserveRepatriated",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "Balance",
            "Status"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "ExistentialDeposit",
          "Type": "T::Balance",
          "Value": "0x00407A10F35A00000000000000000000",
          "Documentations": [
            " The minimum amount required to keep an account open."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " Vesting balance too high to send value"
          ],
          "Name": "VestingBalance"
        },
        {
          "Documentations": [
            " Account liquidity restrictions prevent withdrawal"
          ],
          "Name": "LiquidityRestrictions"
        },
        {
          "Documentations": [
            " Got an overflow after adding"
          ],
          "Name": "Overflow"
        },
        {
          "Documentations": [
            " Balance too low to send value"
          ],
          "Name": "InsufficientBalance"
        },
        {
          "Documentations": [
            " Value too low to create account due to existential deposit"
          ],
          "Name": "ExistentialDeposit"
        },
        {
          "Documentations": [
            " Transfer/payment would kill account"
          ],
          "Name": "KeepAlive"
        },
        {
          "Documentations": [
            " A vesting schedule already exists for this account"
          ],
          "Name": "ExistingVestingSchedule"
        },
        {
          "Documentations": [
            " Beneficiary account must pre-exist"
          ],
          "Name": "DeadAccount"
        }
      ]
    },
    {
      "Name": "TransactionPayment",
      "Index": 7,
      "Storage": {
        "Prefix": "TransactionPayment",
        "Items": [
          {
            "Name": "NextFeeMultiplier",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Multiplier",
              "IsLinked": false
            },
            "FallBack": "0x000064A7B3B6E00D0000000000000000",
            "Documentations": [

            ]
          },
          {
            "Name": "StorageVersion",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Releases",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [

            ]
          }
        ]
      },
      "Calls": null,
      "Events": null,
      "Consts": [
        {
          "Name": "TransactionByteFee",
          "Type": "BalanceOf<T>",
          "Value": "0x00E40B54020000000000000000000000",
          "Documentations": [
            " The fee to be paid for making a transaction; the per-byte portion."
          ]
        },
        {
          "Name": "WeightToFee",
          "Type": "Vec<WeightToFeeCoefficient<BalanceOf<T>>>",
          "Value": "0x0401000000000000000000000000000000000000000001",
          "Documentations": [
            " The polynomial that is applied in order to derive fee from weight."
          ]
        }
      ],
      "Errors": [

      ]
    },
    {
      "Name": "Authorship",
      "Index": 8,
      "Storage": {
        "Prefix": "Authorship",
        "Items": [
          {
            "Name": "Uncles",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<UncleEntryItem<T::BlockNumber, T::Hash, T::AccountId>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Uncles"
            ]
          },
          {
            "Name": "Author",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Author of current block."
            ]
          },
          {
            "Name": "DidSetUncles",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "bool",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Whether uncles were already set in this block."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "set_uncles",
          "Arguments": [
            {
              "Name": "new_uncles",
              "Type": "Vec<T::Header>"
            }
          ],
          "Documentations": [
            " Provide a set of uncles."
          ]
        }
      ],
      "Events": null,
      "Consts": [

      ],
      "Errors": [
        {
          "Documentations": [
            " The uncle parent not in the chain."
          ],
          "Name": "InvalidUncleParent"
        },
        {
          "Documentations": [
            " Uncles already set in the block."
          ],
          "Name": "UnclesAlreadySet"
        },
        {
          "Documentations": [
            " Too many uncles."
          ],
          "Name": "TooManyUncles"
        },
        {
          "Documentations": [
            " The uncle is genesis."
          ],
          "Name": "GenesisUncle"
        },
        {
          "Documentations": [
            " The uncle is too high in chain."
          ],
          "Name": "TooHighUncle"
        },
        {
          "Documentations": [
            " The uncle is already included."
          ],
          "Name": "UncleAlreadyIncluded"
        },
        {
          "Documentations": [
            " The uncle isn't recent enough to be included."
          ],
          "Name": "OldUncle"
        }
      ]
    },
    {
      "Name": "Staking",
      "Index": 9,
      "Storage": {
        "Prefix": "Staking",
        "Items": [
          {
            "Name": "HistoryDepth",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x54000000",
            "Documentations": [
              " Number of eras to keep in history.",
              "",
              " Information is kept for eras in `[current_era - history_depth; current_era]`.",
              "",
              " Must be more than the number of eras delayed by session otherwise. I.e. active era must",
              " always be in history. I.e. `active_era > current_era - history_depth` must be",
              " guaranteed."
            ]
          },
          {
            "Name": "ValidatorCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " The ideal number of staking participants."
            ]
          },
          {
            "Name": "MinimumValidatorCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " Minimum number of staking participants before emergency conditions are imposed."
            ]
          },
          {
            "Name": "Invulnerables",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Any validators that may never be slashed or forcibly kicked. It's a Vec since they're",
              " easy to initialize and the performance hit is minimal (we expect no more than four",
              " invulnerables) and restricted to testnets."
            ]
          },
          {
            "Name": "Bonded",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Map from all locked \"stash\" accounts to the controller account."
            ]
          },
          {
            "Name": "Ledger",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "StakingLedger<T::AccountId, BalanceOf<T>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."
            ]
          },
          {
            "Name": "Payee",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "RewardDestination<T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Where the reward payment should be made. Keyed by stash."
            ]
          },
          {
            "Name": "Validators",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "ValidatorPrefs",
              "IsLinked": false
            },
            "FallBack": "0x0000",
            "Documentations": [
              " The map from (wannabe) validator stash key to the preferences of that validator."
            ]
          },
          {
            "Name": "Nominators",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "Nominations<T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The map from nominator stash key to the set of stash keys of all validators to nominate."
            ]
          },
          {
            "Name": "CurrentEra",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "EraIndex",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current era index.",
              "",
              " This is the latest planned era, depending on how the Session pallet queues the validator",
              " set, it might be active or not."
            ]
          },
          {
            "Name": "ActiveEra",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "ActiveEraInfo",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The active era information, it holds index and start.",
              "",
              " The active era is the era being currently rewarded. Validator set of this era must be",
              " equal to [`SessionInterface::validators`]."
            ]
          },
          {
            "Name": "ErasStartSessionIndex",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "EraIndex",
              "Key2": null,
              "Value": "SessionIndex",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The session index at which the era start for the last `HISTORY_DEPTH` eras.",
              "",
              " Note: This tracks the starting session (i.e. session index when era start being active)",
              " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."
            ]
          },
          {
            "Name": "ErasStakers",
            "Modifier": "Default",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "EraIndex",
              "Key2": "T::AccountId",
              "Value": "Exposure<T::AccountId, BalanceOf<T>>",
              "IsLinked": true
            },
            "FallBack": "0x000000",
            "Documentations": [
              " Exposure of validator at era.",
              "",
              " This is keyed first by the era index to allow bulk deletion and then the stash account.",
              "",
              " Is it removed after `HISTORY_DEPTH` eras.",
              " If stakers hasn't been set or has been removed then empty exposure is returned."
            ]
          },
          {
            "Name": "ErasStakersClipped",
            "Modifier": "Default",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "EraIndex",
              "Key2": "T::AccountId",
              "Value": "Exposure<T::AccountId, BalanceOf<T>>",
              "IsLinked": true
            },
            "FallBack": "0x000000",
            "Documentations": [
              " Clipped Exposure of validator at era.",
              "",
              " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the",
              " `T::MaxNominatorRewardedPerValidator` biggest stakers.",
              " (Note: the field `total` and `own` of the exposure remains unchanged).",
              " This is used to limit the i/o cost for the nominator payout.",
              "",
              " This is keyed fist by the era index to allow bulk deletion and then the stash account.",
              "",
              " Is it removed after `HISTORY_DEPTH` eras.",
              " If stakers hasn't been set or has been removed then empty exposure is returned."
            ]
          },
          {
            "Name": "ErasValidatorPrefs",
            "Modifier": "Default",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "EraIndex",
              "Key2": "T::AccountId",
              "Value": "ValidatorPrefs",
              "IsLinked": true
            },
            "FallBack": "0x0000",
            "Documentations": [
              " Similar to `ErasStakers`, this holds the preferences of validators.",
              "",
              " This is keyed first by the era index to allow bulk deletion and then the stash account.",
              "",
              " Is it removed after `HISTORY_DEPTH` eras."
            ]
          },
          {
            "Name": "ErasValidatorReward",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "EraIndex",
              "Key2": null,
              "Value": "BalanceOf<T>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The total validator era payout for the last `HISTORY_DEPTH` eras.",
              "",
              " Eras that haven't finished yet or has been removed doesn't have reward."
            ]
          },
          {
            "Name": "ErasRewardPoints",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "EraIndex",
              "Key2": null,
              "Value": "EraRewardPoints<T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x0000000000",
            "Documentations": [
              " Rewards for the last `HISTORY_DEPTH` eras.",
              " If reward hasn't been set or has been removed then 0 reward is returned."
            ]
          },
          {
            "Name": "ErasTotalStake",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "EraIndex",
              "Key2": null,
              "Value": "BalanceOf<T>",
              "IsLinked": false
            },
            "FallBack": "0x00000000000000000000000000000000",
            "Documentations": [
              " The total amount staked for the last `HISTORY_DEPTH` eras.",
              " If total hasn't been set or has been removed then 0 stake is returned."
            ]
          },
          {
            "Name": "ForceEra",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Forcing",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Mode of era forcing."
            ]
          },
          {
            "Name": "SlashRewardFraction",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Perbill",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " The percentage of the slash that is distributed to reporters.",
              "",
              " The rest of the slashed value is handled by the `Slash`."
            ]
          },
          {
            "Name": "CanceledSlashPayout",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "BalanceOf<T>",
              "IsLinked": false
            },
            "FallBack": "0x00000000000000000000000000000000",
            "Documentations": [
              " The amount of currency given to reporters of a slash event which was",
              " canceled by extraordinary circumstances (e.g. governance)."
            ]
          },
          {
            "Name": "UnappliedSlashes",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "EraIndex",
              "Key2": null,
              "Value": "Vec<UnappliedSlash<T::AccountId, BalanceOf<T>>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " All unapplied slashes that are queued for later."
            ]
          },
          {
            "Name": "BondedEras",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<(EraIndex, SessionIndex)>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A mapping from still-bonded eras to the first session index of that era.",
              "",
              " Must contains information for eras for the range:",
              " `[active_era - bounding_duration; active_era]`"
            ]
          },
          {
            "Name": "ValidatorSlashInEra",
            "Modifier": "Optional",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "EraIndex",
              "Key2": "T::AccountId",
              "Value": "(Perbill, BalanceOf<T>)",
              "IsLinked": true
            },
            "FallBack": "0x00",
            "Documentations": [
              " All slashing events on validators, mapped by era to the highest slash proportion",
              " and slash value of the era."
            ]
          },
          {
            "Name": "NominatorSlashInEra",
            "Modifier": "Optional",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "EraIndex",
              "Key2": "T::AccountId",
              "Value": "BalanceOf<T>",
              "IsLinked": true
            },
            "FallBack": "0x00",
            "Documentations": [
              " All slashing events on nominators, mapped by era to the highest slash value of the era."
            ]
          },
          {
            "Name": "SlashingSpans",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "slashing::SlashingSpans",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Slashing spans for stash accounts."
            ]
          },
          {
            "Name": "SpanSlash",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "(T::AccountId, slashing::SpanIndex)",
              "Key2": null,
              "Value": "slashing::SpanRecord<BalanceOf<T>>",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " Records information about the maximum slash of a stash within a slashing span,",
              " as well as how much reward has been paid out."
            ]
          },
          {
            "Name": "EarliestUnappliedSlash",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "EraIndex",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The earliest era for which we have a pending, unapplied slash."
            ]
          },
          {
            "Name": "SnapshotValidators",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Snapshot of validators at the beginning of the current election window. This should only",
              " have a value when [`EraElectionStatus`] == `ElectionStatus::Open(_)`."
            ]
          },
          {
            "Name": "SnapshotNominators",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Snapshot of nominators at the beginning of the current election window. This should only",
              " have a value when [`EraElectionStatus`] == `ElectionStatus::Open(_)`."
            ]
          },
          {
            "Name": "QueuedElected",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "ElectionResult<T::AccountId, BalanceOf<T>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The next validator set. At the end of an era, if this is available (potentially from the",
              " result of an offchain worker), it is immediately used. Otherwise, the on-chain election",
              " is executed."
            ]
          },
          {
            "Name": "QueuedScore",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "ElectionScore",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The score of the current [`QueuedElected`]."
            ]
          },
          {
            "Name": "EraElectionStatus",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "ElectionStatus<T::BlockNumber>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Flag to control the execution of the offchain election. When `Open(_)`, we accept",
              " solutions to be submitted."
            ]
          },
          {
            "Name": "IsCurrentSessionFinal",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "bool",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " True if the current **planned** session is final. Note that this does not take era",
              " forcing into account."
            ]
          },
          {
            "Name": "StorageVersion",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Releases",
              "IsLinked": false
            },
            "FallBack": "0x04",
            "Documentations": [
              " True if network has been upgraded to this version.",
              " Storage version of the pallet.",
              "",
              " This is set to v5.0.0 for new networks."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "bond",
          "Arguments": [
            {
              "Name": "controller",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "value",
              "Type": "Compact<BalanceOf<T>>"
            },
            {
              "Name": "payee",
              "Type": "RewardDestination<T::AccountId>"
            }
          ],
          "Documentations": [
            " Take the origin account as a stash and lock up `value` of its balance. `controller` will",
            " be the account that controls it.",
            "",
            " `value` must be more than the `minimum_balance` specified by `T::Currency`.",
            "",
            " The dispatch origin for this call must be _Signed_ by the stash account.",
            "",
            " Emits `Bonded`.",
            "",
            " # <weight>",
            " - Independent of the arguments. Moderate complexity.",
            " - O(1).",
            " - Three extra DB entries.",
            "",
            " NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned",
            " unless the `origin` falls below _existential deposit_ and gets removed as dust.",
            " ------------------",
            " Weight: O(1)",
            " DB Weight:",
            " - Read: Bonded, Ledger, [Origin Account], Current Era, History Depth, Locks",
            " - Write: Bonded, Payee, [Origin Account], Locks, Ledger",
            " # </weight>"
          ]
        },
        {
          "Name": "bond_extra",
          "Arguments": [
            {
              "Name": "max_additional",
              "Type": "Compact<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Add some extra amount that have appeared in the stash `free_balance` into the balance up",
            " for staking.",
            "",
            " Use this if there are additional funds in your stash account that you wish to bond.",
            " Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount",
            " that can be added.",
            "",
            " The dispatch origin for this call must be _Signed_ by the stash, not the controller and",
            " it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " Emits `Bonded`.",
            "",
            " # <weight>",
            " - Independent of the arguments. Insignificant complexity.",
            " - O(1).",
            " - One DB entry.",
            " ------------",
            " DB Weight:",
            " - Read: Era Election Status, Bonded, Ledger, [Origin Account], Locks",
            " - Write: [Origin Account], Locks, Ledger",
            " # </weight>"
          ]
        },
        {
          "Name": "unbond",
          "Arguments": [
            {
              "Name": "value",
              "Type": "Compact<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Schedule a portion of the stash to be unlocked ready for transfer out after the bond",
            " period ends. If this leaves an amount actively bonded less than",
            " T::Currency::minimum_balance(), then it is increased to the full amount.",
            "",
            " Once the unlock period is done, you can call `withdraw_unbonded` to actually move",
            " the funds out of management ready for transfer.",
            "",
            " No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)",
            " can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need",
            " to be called first to remove some of the chunks (if possible).",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            " And, it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " Emits `Unbonded`.",
            "",
            " See also [`Call::withdraw_unbonded`].",
            "",
            " # <weight>",
            " - Independent of the arguments. Limited but potentially exploitable complexity.",
            " - Contains a limited number of reads.",
            " - Each call (requires the remainder of the bonded balance to be above `minimum_balance`)",
            "   will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage.",
            "   The only way to clean the aforementioned storage item is also user-controlled via",
            "   `withdraw_unbonded`.",
            " - One DB entry.",
            " ----------",
            " Weight: O(1)",
            " DB Weight:",
            " - Read: EraElectionStatus, Ledger, CurrentEra, Locks, BalanceOf Stash,",
            " - Write: Locks, Ledger, BalanceOf Stash,",
            " </weight>"
          ]
        },
        {
          "Name": "withdraw_unbonded",
          "Arguments": [
            {
              "Name": "num_slashing_spans",
              "Type": "u32"
            }
          ],
          "Documentations": [
            " Remove any unlocked chunks from the `unlocking` queue from our management.",
            "",
            " This essentially frees up that balance to be used by the stash account to do",
            " whatever it wants.",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            " And, it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " Emits `Withdrawn`.",
            "",
            " See also [`Call::unbond`].",
            "",
            " # <weight>",
            " - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.",
            "  It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is",
            "  indirectly user-controlled. See [`unbond`] for more detail.",
            " - Contains a limited number of reads, yet the size of which could be large based on `ledger`.",
            " - Writes are limited to the `origin` account key.",
            " ---------------",
            " Complexity O(S) where S is the number of slashing spans to remove",
            " Update:",
            " - Reads: EraElectionStatus, Ledger, Current Era, Locks, [Origin Account]",
            " - Writes: [Origin Account], Locks, Ledger",
            " Kill:",
            " - Reads: EraElectionStatus, Ledger, Current Era, Bonded, Slashing Spans, [Origin",
            "   Account], Locks, BalanceOf stash",
            " - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators,",
            "   [Origin Account], Locks, BalanceOf stash.",
            " - Writes Each: SpanSlash * S",
            " NOTE: Weight annotation is the kill scenario, we refund otherwise.",
            " # </weight>"
          ]
        },
        {
          "Name": "validate",
          "Arguments": [
            {
              "Name": "prefs",
              "Type": "ValidatorPrefs"
            }
          ],
          "Documentations": [
            " Declare the desire to validate for the origin controller.",
            "",
            " Effects will be felt at the beginning of the next era.",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            " And, it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " # <weight>",
            " - Independent of the arguments. Insignificant complexity.",
            " - Contains a limited number of reads.",
            " - Writes are limited to the `origin` account key.",
            " -----------",
            " Weight: O(1)",
            " DB Weight:",
            " - Read: Era Election Status, Ledger",
            " - Write: Nominators, Validators",
            " # </weight>"
          ]
        },
        {
          "Name": "nominate",
          "Arguments": [
            {
              "Name": "targets",
              "Type": "Vec<<T::Lookup as StaticLookup>::Source>"
            }
          ],
          "Documentations": [
            " Declare the desire to nominate `targets` for the origin controller.",
            "",
            " Effects will be felt at the beginning of the next era. This can only be called when",
            " [`EraElectionStatus`] is `Closed`.",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            " And, it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " # <weight>",
            " - The transaction's complexity is proportional to the size of `targets` (N)",
            " which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS).",
            " - Both the reads and writes follow a similar pattern.",
            " ---------",
            " Weight: O(N)",
            " where N is the number of targets",
            " DB Weight:",
            " - Reads: Era Election Status, Ledger, Current Era",
            " - Writes: Validators, Nominators",
            " # </weight>"
          ]
        },
        {
          "Name": "chill",
          "Arguments": [

          ],
          "Documentations": [
            " Declare no desire to either validate or nominate.",
            "",
            " Effects will be felt at the beginning of the next era.",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            " And, it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " # <weight>",
            " - Independent of the arguments. Insignificant complexity.",
            " - Contains one read.",
            " - Writes are limited to the `origin` account key.",
            " --------",
            " Weight: O(1)",
            " DB Weight:",
            " - Read: EraElectionStatus, Ledger",
            " - Write: Validators, Nominators",
            " # </weight>"
          ]
        },
        {
          "Name": "set_payee",
          "Arguments": [
            {
              "Name": "payee",
              "Type": "RewardDestination<T::AccountId>"
            }
          ],
          "Documentations": [
            " (Re-)set the payment target for a controller.",
            "",
            " Effects will be felt at the beginning of the next era.",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            "",
            " # <weight>",
            " - Independent of the arguments. Insignificant complexity.",
            " - Contains a limited number of reads.",
            " - Writes are limited to the `origin` account key.",
            " ---------",
            " - Weight: O(1)",
            " - DB Weight:",
            "     - Read: Ledger",
            "     - Write: Payee",
            " # </weight>"
          ]
        },
        {
          "Name": "set_controller",
          "Arguments": [
            {
              "Name": "controller",
              "Type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "Documentations": [
            " (Re-)set the controller of a stash.",
            "",
            " Effects will be felt at the beginning of the next era.",
            "",
            " The dispatch origin for this call must be _Signed_ by the stash, not the controller.",
            "",
            " # <weight>",
            " - Independent of the arguments. Insignificant complexity.",
            " - Contains a limited number of reads.",
            " - Writes are limited to the `origin` account key.",
            " ----------",
            " Weight: O(1)",
            " DB Weight:",
            " - Read: Bonded, Ledger New Controller, Ledger Old Controller",
            " - Write: Bonded, Ledger New Controller, Ledger Old Controller",
            " # </weight>"
          ]
        },
        {
          "Name": "set_validator_count",
          "Arguments": [
            {
              "Name": "new",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Sets the ideal number of validators.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " Weight: O(1)",
            " Write: Validator Count",
            " # </weight>"
          ]
        },
        {
          "Name": "increase_validator_count",
          "Arguments": [
            {
              "Name": "additional",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Increments the ideal number of validators.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " Same as [`set_validator_count`].",
            " # </weight>"
          ]
        },
        {
          "Name": "scale_validator_count",
          "Arguments": [
            {
              "Name": "factor",
              "Type": "Percent"
            }
          ],
          "Documentations": [
            " Scale up the ideal number of validators by a factor.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " Same as [`set_validator_count`].",
            " # </weight>"
          ]
        },
        {
          "Name": "force_no_eras",
          "Arguments": [

          ],
          "Documentations": [
            " Force there to be no new eras indefinitely.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " - No arguments.",
            " - Weight: O(1)",
            " - Write: ForceEra",
            " # </weight>"
          ]
        },
        {
          "Name": "force_new_era",
          "Arguments": [

          ],
          "Documentations": [
            " Force there to be a new era at the end of the next session. After this, it will be",
            " reset to normal (non-forced) behaviour.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " - No arguments.",
            " - Weight: O(1)",
            " - Write ForceEra",
            " # </weight>"
          ]
        },
        {
          "Name": "set_invulnerables",
          "Arguments": [
            {
              "Name": "invulnerables",
              "Type": "Vec<T::AccountId>"
            }
          ],
          "Documentations": [
            " Set the validators who cannot be slashed (if any).",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " - O(V)",
            " - Write: Invulnerables",
            " # </weight>"
          ]
        },
        {
          "Name": "force_unstake",
          "Arguments": [
            {
              "Name": "stash",
              "Type": "T::AccountId"
            },
            {
              "Name": "num_slashing_spans",
              "Type": "u32"
            }
          ],
          "Documentations": [
            " Force a current staker to become completely unstaked, immediately.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " O(S) where S is the number of slashing spans to be removed",
            " Reads: Bonded, Slashing Spans, Account, Locks",
            " Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Account, Locks",
            " Writes Each: SpanSlash * S",
            " # </weight>"
          ]
        },
        {
          "Name": "force_new_era_always",
          "Arguments": [

          ],
          "Documentations": [
            " Force there to be a new era at the end of sessions indefinitely.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " - Weight: O(1)",
            " - Write: ForceEra",
            " # </weight>"
          ]
        },
        {
          "Name": "cancel_deferred_slash",
          "Arguments": [
            {
              "Name": "era",
              "Type": "EraIndex"
            },
            {
              "Name": "slash_indices",
              "Type": "Vec<u32>"
            }
          ],
          "Documentations": [
            " Cancel enactment of a deferred slash.",
            "",
            " Can be called by the `T::SlashCancelOrigin`.",
            "",
            " Parameters: era and indices of the slashes for that era to kill.",
            "",
            " # <weight>",
            " Complexity: O(U + S)",
            " with U unapplied slashes weighted with U=1000",
            " and S is the number of slash indices to be canceled.",
            " - Read: Unapplied Slashes",
            " - Write: Unapplied Slashes",
            " # </weight>"
          ]
        },
        {
          "Name": "payout_stakers",
          "Arguments": [
            {
              "Name": "validator_stash",
              "Type": "T::AccountId"
            },
            {
              "Name": "era",
              "Type": "EraIndex"
            }
          ],
          "Documentations": [
            " Pay out all the stakers behind a single validator for a single era.",
            "",
            " - `validator_stash` is the stash account of the validator. Their nominators, up to",
            "   `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.",
            " - `era` may be any era between `[current_era - history_depth; current_era]`.",
            "",
            " The origin of this call must be _Signed_. Any account can call this function, even if",
            " it is not one of the stakers.",
            "",
            " This can only be called when [`EraElectionStatus`] is `Closed`.",
            "",
            " # <weight>",
            " - Time complexity: at most O(MaxNominatorRewardedPerValidator).",
            " - Contains a limited number of reads and writes.",
            " -----------",
            " N is the Number of payouts for the validator (including the validator)",
            " Weight:",
            " - Reward Destination Staked: O(N)",
            " - Reward Destination Controller (Creating): O(N)",
            " DB Weight:",
            " - Read: EraElectionStatus, CurrentEra, HistoryDepth, ErasValidatorReward,",
            "         ErasStakersClipped, ErasRewardPoints, ErasValidatorPrefs (8 items)",
            " - Read Each: Bonded, Ledger, Payee, Locks, System Account (5 items)",
            " - Write Each: System Account, Locks, Ledger (3 items)",
            "",
            "   NOTE: weights are assuming that payouts are made to alive stash account (Staked).",
            "   Paying even a dead controller is cheaper weight-wise. We don't do any refunds here.",
            " # </weight>"
          ]
        },
        {
          "Name": "rebond",
          "Arguments": [
            {
              "Name": "value",
              "Type": "Compact<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Rebond a portion of the stash scheduled to be unlocked.",
            "",
            " The dispatch origin must be signed by the controller, and it can be only called when",
            " [`EraElectionStatus`] is `Closed`.",
            "",
            " # <weight>",
            " - Time complexity: O(L), where L is unlocking chunks",
            " - Bounded by `MAX_UNLOCKING_CHUNKS`.",
            " - Storage changes: Can't increase storage, only decrease it.",
            " ---------------",
            " - DB Weight:",
            "     - Reads: EraElectionStatus, Ledger, Locks, [Origin Account]",
            "     - Writes: [Origin Account], Locks, Ledger",
            " # </weight>"
          ]
        },
        {
          "Name": "set_history_depth",
          "Arguments": [
            {
              "Name": "new_history_depth",
              "Type": "Compact<EraIndex>"
            },
            {
              "Name": "_era_items_deleted",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Set `HistoryDepth` value. This function will delete any history information",
            " when `HistoryDepth` is reduced.",
            "",
            " Parameters:",
            " - `new_history_depth`: The new history depth you would like to set.",
            " - `era_items_deleted`: The number of items that will be deleted by this dispatch.",
            "    This should report all the storage items that will be deleted by clearing old",
            "    era history. Needed to report an accurate weight for the dispatch. Trusted by",
            "    `Root` to report an accurate number.",
            "",
            " Origin must be root.",
            "",
            " # <weight>",
            " - E: Number of history depths removed, i.e. 10 -> 7 = 3",
            " - Weight: O(E)",
            " - DB Weight:",
            "     - Reads: Current Era, History Depth",
            "     - Writes: History Depth",
            "     - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs",
            "     - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake, ErasStartSessionIndex",
            " # </weight>"
          ]
        },
        {
          "Name": "reap_stash",
          "Arguments": [
            {
              "Name": "stash",
              "Type": "T::AccountId"
            },
            {
              "Name": "num_slashing_spans",
              "Type": "u32"
            }
          ],
          "Documentations": [
            " Remove all data structure concerning a staker/stash once its balance is at the minimum.",
            " This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone",
            " and the target `stash` must have no funds left beyond the ED.",
            "",
            " This can be called from any origin.",
            "",
            " - `stash`: The stash account to reap. Its balance must be zero.",
            "",
            " # <weight>",
            " Complexity: O(S) where S is the number of slashing spans on the account.",
            " DB Weight:",
            " - Reads: Stash Account, Bonded, Slashing Spans, Locks",
            " - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Stash Account, Locks",
            " - Writes Each: SpanSlash * S",
            " # </weight>"
          ]
        },
        {
          "Name": "submit_election_solution",
          "Arguments": [
            {
              "Name": "winners",
              "Type": "Vec<ValidatorIndex>"
            },
            {
              "Name": "compact",
              "Type": "CompactAssignments"
            },
            {
              "Name": "score",
              "Type": "ElectionScore"
            },
            {
              "Name": "era",
              "Type": "EraIndex"
            },
            {
              "Name": "size",
              "Type": "ElectionSize"
            }
          ],
          "Documentations": [
            " Submit an election result to the chain. If the solution:",
            "",
            " 1. is valid.",
            " 2. has a better score than a potentially existing solution on chain.",
            "",
            " then, it will be _put_ on chain.",
            "",
            " A solution consists of two pieces of data:",
            "",
            " 1. `winners`: a flat vector of all the winners of the round.",
            " 2. `assignments`: the compact version of an assignment vector that encodes the edge",
            "    weights.",
            "",
            " Both of which may be computed using _phragmen_, or any other algorithm.",
            "",
            " Additionally, the submitter must provide:",
            "",
            " - The `score` that they claim their solution has.",
            "",
            " Both validators and nominators will be represented by indices in the solution. The",
            " indices should respect the corresponding types ([`ValidatorIndex`] and",
            " [`NominatorIndex`]). Moreover, they should be valid when used to index into",
            " [`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the",
            " solution to be rejected. These two storage items are set during the election window and",
            " may be used to determine the indices.",
            "",
            " A solution is valid if:",
            "",
            " 0. It is submitted when [`EraElectionStatus`] is `Open`.",
            " 1. Its claimed score is equal to the score computed on-chain.",
            " 2. Presents the correct number of winners.",
            " 3. All indexes must be value according to the snapshot vectors. All edge values must",
            "    also be correct and should not overflow the granularity of the ratio type (i.e. 256",
            "    or billion).",
            " 4. For each edge, all targets are actually nominated by the voter.",
            " 5. Has correct self-votes.",
            "",
            " A solutions score is consisted of 3 parameters:",
            "",
            " 1. `min { support.total }` for each support of a winner. This value should be maximized.",
            " 2. `sum { support.total }` for each support of a winner. This value should be minimized.",
            " 3. `sum { support.total^2 }` for each support of a winner. This value should be",
            "    minimized (to ensure less variance)",
            "",
            " # <weight>",
            " The transaction is assumed to be the longest path, a better solution.",
            "   - Initial solution is almost the same.",
            "   - Worse solution is retraced in pre-dispatch-checks which sets its own weight.",
            " # </weight>"
          ]
        },
        {
          "Name": "submit_election_solution_unsigned",
          "Arguments": [
            {
              "Name": "winners",
              "Type": "Vec<ValidatorIndex>"
            },
            {
              "Name": "compact",
              "Type": "CompactAssignments"
            },
            {
              "Name": "score",
              "Type": "ElectionScore"
            },
            {
              "Name": "era",
              "Type": "EraIndex"
            },
            {
              "Name": "size",
              "Type": "ElectionSize"
            }
          ],
          "Documentations": [
            " Unsigned version of `submit_election_solution`.",
            "",
            " Note that this must pass the [`ValidateUnsigned`] check which only allows transactions",
            " from the local node to be included. In other words, only the block author can include a",
            " transaction in the block.",
            "",
            " # <weight>",
            " See [`submit_election_solution`].",
            " # </weight>"
          ]
        },
        {
          "Name": "kick",
          "Arguments": [
            {
              "Name": "who",
              "Type": "Vec<<T::Lookup as StaticLookup>::Source>"
            }
          ],
          "Documentations": [
            " Remove the given nominations from the calling validator.",
            "",
            " Effects will be felt at the beginning of the next era.",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            " And, it can be only called when [`EraElectionStatus`] is `Closed`. The controller",
            " account should represent a validator.",
            "",
            " - `who`: A list of nominator stash accounts who are nominating this validator which",
            "   should no longer be nominating this validator.",
            "",
            " Note: Making this call only makes sense if you first set the validator preferences to",
            " block any further nominations."
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " The era payout has been set; the first balance is the validator-payout; the second is",
            " the remainder from the maximum amount of reward.",
            " \\[era_index, validator_payout, remainder\\]"
          ],
          "Name": "EraPayout",
          "EventArgs": [
            "EraIndex",
            "Balance",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " The staker has been rewarded by this amount. \\[stash, amount\\]"
          ],
          "Name": "Reward",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " One validator (and its nominators) has been slashed by the given amount.",
            " \\[validator, amount\\]"
          ],
          "Name": "Slash",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " An old slashing report from a prior era was discarded because it could",
            " not be processed. \\[session_index\\]"
          ],
          "Name": "OldSlashingReportDiscarded",
          "EventArgs": [
            "SessionIndex"
          ]
        },
        {
          "Documentations": [
            " A new set of stakers was elected with the given \\[compute\\]."
          ],
          "Name": "StakingElection",
          "EventArgs": [
            "ElectionCompute"
          ]
        },
        {
          "Documentations": [
            " A new solution for the upcoming election has been stored. \\[compute\\]"
          ],
          "Name": "SolutionStored",
          "EventArgs": [
            "ElectionCompute"
          ]
        },
        {
          "Documentations": [
            " An account has bonded this amount. \\[stash, amount\\]",
            "",
            " NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,",
            " it will not be emitted for staking rewards when they are added to stake."
          ],
          "Name": "Bonded",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " An account has unbonded this amount. \\[stash, amount\\]"
          ],
          "Name": "Unbonded",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`",
            " from the unlocking queue. \\[stash, amount\\]"
          ],
          "Name": "Withdrawn",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A nominator has been kicked from a validator. \\[nominator, stash\\]"
          ],
          "Name": "Kicked",
          "EventArgs": [
            "AccountId",
            "AccountId"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "SessionsPerEra",
          "Type": "SessionIndex",
          "Value": "0x06000000",
          "Documentations": [
            " Number of sessions per era."
          ]
        },
        {
          "Name": "BondingDuration",
          "Type": "EraIndex",
          "Value": "0xA0020000",
          "Documentations": [
            " Number of eras that staked funds must remain bonded for."
          ]
        },
        {
          "Name": "SlashDeferDuration",
          "Type": "EraIndex",
          "Value": "0xA8000000",
          "Documentations": [
            " Number of eras that slashes are deferred by, after computation.",
            "",
            " This should be less than the bonding duration.",
            " Set to 0 if slashes should be applied immediately, without opportunity for",
            " intervention."
          ]
        },
        {
          "Name": "ElectionLookahead",
          "Type": "T::BlockNumber",
          "Value": "0x32000000",
          "Documentations": [
            " The number of blocks before the end of the era from which election submissions are allowed.",
            "",
            " Setting this to zero will disable the offchain compute and only on-chain seq-phragmen will",
            " be used.",
            "",
            " This is bounded by being within the last session. Hence, setting it to a value more than the",
            " length of a session will be pointless."
          ]
        },
        {
          "Name": "MaxIterations",
          "Type": "u32",
          "Value": "0x0A000000",
          "Documentations": [
            " Maximum number of balancing iterations to run in the offchain submission.",
            "",
            " If set to 0, balance_solution will not be executed at all."
          ]
        },
        {
          "Name": "MinSolutionScoreBump",
          "Type": "Perbill",
          "Value": "0x20A10700",
          "Documentations": [
            " The threshold of improvement that should be provided for a new solution to be accepted."
          ]
        },
        {
          "Name": "MaxNominatorRewardedPerValidator",
          "Type": "u32",
          "Value": "0x00010000",
          "Documentations": [
            " The maximum number of nominators rewarded for each validator.",
            "",
            " For each validator only the `$MaxNominatorRewardedPerValidator` biggest stakers can claim",
            " their reward. This used to limit the i/o cost for the nominator payout."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " Not a controller account."
          ],
          "Name": "NotController"
        },
        {
          "Documentations": [
            " Not a stash account."
          ],
          "Name": "NotStash"
        },
        {
          "Documentations": [
            " Stash is already bonded."
          ],
          "Name": "AlreadyBonded"
        },
        {
          "Documentations": [
            " Controller is already paired."
          ],
          "Name": "AlreadyPaired"
        },
        {
          "Documentations": [
            " Targets cannot be empty."
          ],
          "Name": "EmptyTargets"
        },
        {
          "Documentations": [
            " Duplicate index."
          ],
          "Name": "DuplicateIndex"
        },
        {
          "Documentations": [
            " Slash record index out of bounds."
          ],
          "Name": "InvalidSlashIndex"
        },
        {
          "Documentations": [
            " Can not bond with value less than minimum balance."
          ],
          "Name": "InsufficientValue"
        },
        {
          "Documentations": [
            " Can not schedule more unlock chunks."
          ],
          "Name": "NoMoreChunks"
        },
        {
          "Documentations": [
            " Can not rebond without unlocking chunks."
          ],
          "Name": "NoUnlockChunk"
        },
        {
          "Documentations": [
            " Attempting to target a stash that still has funds."
          ],
          "Name": "FundedTarget"
        },
        {
          "Documentations": [
            " Invalid era to reward."
          ],
          "Name": "InvalidEraToReward"
        },
        {
          "Documentations": [
            " Invalid number of nominations."
          ],
          "Name": "InvalidNumberOfNominations"
        },
        {
          "Documentations": [
            " Items are not sorted and unique."
          ],
          "Name": "NotSortedAndUnique"
        },
        {
          "Documentations": [
            " Rewards for this era have already been claimed for this validator."
          ],
          "Name": "AlreadyClaimed"
        },
        {
          "Documentations": [
            " The submitted result is received out of the open window."
          ],
          "Name": "OffchainElectionEarlySubmission"
        },
        {
          "Documentations": [
            " The submitted result is not as good as the one stored on chain."
          ],
          "Name": "OffchainElectionWeakSubmission"
        },
        {
          "Documentations": [
            " The snapshot data of the current window is missing."
          ],
          "Name": "SnapshotUnavailable"
        },
        {
          "Documentations": [
            " Incorrect number of winners were presented."
          ],
          "Name": "OffchainElectionBogusWinnerCount"
        },
        {
          "Documentations": [
            " One of the submitted winners is not an active candidate on chain (index is out of range",
            " in snapshot)."
          ],
          "Name": "OffchainElectionBogusWinner"
        },
        {
          "Documentations": [
            " Error while building the assignment type from the compact. This can happen if an index",
            " is invalid, or if the weights _overflow_."
          ],
          "Name": "OffchainElectionBogusCompact"
        },
        {
          "Documentations": [
            " One of the submitted nominators is not an active nominator on chain."
          ],
          "Name": "OffchainElectionBogusNominator"
        },
        {
          "Documentations": [
            " One of the submitted nominators has an edge to which they have not voted on chain."
          ],
          "Name": "OffchainElectionBogusNomination"
        },
        {
          "Documentations": [
            " One of the submitted nominators has an edge which is submitted before the last non-zero",
            " slash of the target."
          ],
          "Name": "OffchainElectionSlashedNomination"
        },
        {
          "Documentations": [
            " A self vote must only be originated from a validator to ONLY themselves."
          ],
          "Name": "OffchainElectionBogusSelfVote"
        },
        {
          "Documentations": [
            " The submitted result has unknown edges that are not among the presented winners."
          ],
          "Name": "OffchainElectionBogusEdge"
        },
        {
          "Documentations": [
            " The claimed score does not match with the one computed from the data."
          ],
          "Name": "OffchainElectionBogusScore"
        },
        {
          "Documentations": [
            " The election size is invalid."
          ],
          "Name": "OffchainElectionBogusElectionSize"
        },
        {
          "Documentations": [
            " The call is not allowed at the given time due to restrictions of election period."
          ],
          "Name": "CallNotAllowed"
        },
        {
          "Documentations": [
            " Incorrect previous history depth input provided."
          ],
          "Name": "IncorrectHistoryDepth"
        },
        {
          "Documentations": [
            " Incorrect number of slashing spans provided."
          ],
          "Name": "IncorrectSlashingSpans"
        },
        {
          "Documentations": [
            " Internal state has become somehow corrupted and the operation cannot continue."
          ],
          "Name": "BadState"
        },
        {
          "Documentations": [
            " Too many nomination targets supplied."
          ],
          "Name": "TooManyTargets"
        },
        {
          "Documentations": [
            " A nomination target was supplied that was blocked or otherwise not a validator."
          ],
          "Name": "BadTarget"
        }
      ]
    },
    {
      "Name": "Offences",
      "Index": 10,
      "Storage": {
        "Prefix": "Offences",
        "Items": [
          {
            "Name": "Reports",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "ReportIdOf<T>",
              "Key2": null,
              "Value": "OffenceDetails<T::AccountId, T::IdentificationTuple>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The primary structure that holds all offence records keyed by report identifiers."
            ]
          },
          {
            "Name": "DeferredOffences",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<DeferredOffenceOf<T>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Deferred reports that have been rejected by the offence handler and need to be submitted",
              " at a later time."
            ]
          },
          {
            "Name": "ConcurrentReportsIndex",
            "Modifier": "Default",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "Kind",
              "Key2": "OpaqueTimeSlot",
              "Value": "Vec<ReportIdOf<T>>",
              "IsLinked": true
            },
            "FallBack": "0x00",
            "Documentations": [
              " A vector of reports of the same kind that happened at the same time slot."
            ]
          },
          {
            "Name": "ReportsByKindIndex",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "Kind",
              "Key2": null,
              "Value": "Vec<u8>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Enumerates all reports of a kind along with the time they happened.",
              "",
              " All reports are sorted by the time of offence.",
              "",
              " Note that the actual type of this mapping is `Vec<u8>`, this is because values of",
              " different types are not supported at the moment so we are doing the manual serialization."
            ]
          }
        ]
      },
      "Calls": [

      ],
      "Events": [
        {
          "Documentations": [
            " There is an offence reported of the given `kind` happened at the `session_index` and",
            " (kind-specific) time slot. This event is not deposited for duplicate slashes. last",
            " element indicates of the offence was applied (true) or queued (false)",
            " \\[kind, timeslot, applied\\]."
          ],
          "Name": "Offence",
          "EventArgs": [
            "Kind",
            "OpaqueTimeSlot",
            "bool"
          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [

      ]
    },
    {
      "Name": "Historical",
      "Index": 11,
      "Storage": null,
      "Calls": null,
      "Events": null,
      "Consts": [

      ],
      "Errors": [

      ]
    },
    {
      "Name": "Session",
      "Index": 12,
      "Storage": {
        "Prefix": "Session",
        "Items": [
          {
            "Name": "Validators",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::ValidatorId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current set of validators."
            ]
          },
          {
            "Name": "CurrentIndex",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "SessionIndex",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " Current index of the session."
            ]
          },
          {
            "Name": "QueuedChanged",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "bool",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " True if the underlying economic identities or weighting behind the validators",
              " has changed in the queued validator set."
            ]
          },
          {
            "Name": "QueuedKeys",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<(T::ValidatorId, T::Keys)>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The queued keys for the next session. When the next session begins, these keys",
              " will be used to determine the validator's session keys."
            ]
          },
          {
            "Name": "DisabledValidators",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<u32>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Indices of disabled validators.",
              "",
              " The set is cleared when `on_session_ending` returns a new set of identities."
            ]
          },
          {
            "Name": "NextKeys",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::ValidatorId",
              "Key2": null,
              "Value": "T::Keys",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The next session keys for a validator."
            ]
          },
          {
            "Name": "KeyOwner",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "(KeyTypeId, Vec<u8>)",
              "Key2": null,
              "Value": "T::ValidatorId",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The owner of a key. The key is the `KeyTypeId` + the encoded key."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "set_keys",
          "Arguments": [
            {
              "Name": "keys",
              "Type": "T::Keys"
            },
            {
              "Name": "proof",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Sets the session key(s) of the function caller to `keys`.",
            " Allows an account to set its session key prior to becoming a validator.",
            " This doesn't take effect until the next session.",
            "",
            " The dispatch origin of this function must be signed.",
            "",
            " # <weight>",
            " - Complexity: `O(1)`",
            "   Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.",
            " - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`",
            " - DbWrites: `origin account`, `NextKeys`",
            " - DbReads per key id: `KeyOwner`",
            " - DbWrites per key id: `KeyOwner`",
            " # </weight>"
          ]
        },
        {
          "Name": "purge_keys",
          "Arguments": [

          ],
          "Documentations": [
            " Removes any session key(s) of the function caller.",
            " This doesn't take effect until the next session.",
            "",
            " The dispatch origin of this function must be signed.",
            "",
            " # <weight>",
            " - Complexity: `O(1)` in number of key types.",
            "   Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.",
            " - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`",
            " - DbWrites: `NextKeys`, `origin account`",
            " - DbWrites per key id: `KeyOwnder`",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " New session has happened. Note that the argument is the \\[session_index\\], not the block",
            " number as the type might suggest."
          ],
          "Name": "NewSession",
          "EventArgs": [
            "SessionIndex"
          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [
        {
          "Documentations": [
            " Invalid ownership proof."
          ],
          "Name": "InvalidProof"
        },
        {
          "Documentations": [
            " No associated validator ID for account."
          ],
          "Name": "NoAssociatedValidatorId"
        },
        {
          "Documentations": [
            " Registered duplicate key."
          ],
          "Name": "DuplicatedKey"
        },
        {
          "Documentations": [
            " No keys are associated with this account."
          ],
          "Name": "NoKeys"
        },
        {
          "Documentations": [
            " Key setting account is not live, so it's impossible to associate keys."
          ],
          "Name": "NoAccount"
        }
      ]
    },
    {
      "Name": "Grandpa",
      "Index": 13,
      "Storage": {
        "Prefix": "GrandpaFinality",
        "Items": [
          {
            "Name": "State",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "StoredState<T::BlockNumber>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " State of the current authority set."
            ]
          },
          {
            "Name": "PendingChange",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "StoredPendingChange<T::BlockNumber>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Pending change: (signaled at, scheduled change)."
            ]
          },
          {
            "Name": "NextForced",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::BlockNumber",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " next block number where we can force a change."
            ]
          },
          {
            "Name": "Stalled",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "(T::BlockNumber, T::BlockNumber)",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " `true` if we are currently stalled."
            ]
          },
          {
            "Name": "CurrentSetId",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "SetId",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " The number of changes (both in terms of keys and underlying economic responsibilities)",
              " in the \"set\" of Grandpa validators from genesis."
            ]
          },
          {
            "Name": "SetIdSession",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "SetId",
              "Key2": null,
              "Value": "SessionIndex",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A mapping from grandpa set ID to the index of the *most recent* session for which its",
              " members were responsible.",
              "",
              " TWOX-NOTE: `SetId` is not under user control."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "report_equivocation",
          "Arguments": [
            {
              "Name": "equivocation_proof",
              "Type": "EquivocationProof<T::Hash, T::BlockNumber>"
            },
            {
              "Name": "key_owner_proof",
              "Type": "T::KeyOwnerProof"
            }
          ],
          "Documentations": [
            " Report voter equivocation/misbehavior. This method will verify the",
            " equivocation proof and validate the given key ownership proof",
            " against the extracted offender. If both are valid, the offence",
            " will be reported."
          ]
        },
        {
          "Name": "report_equivocation_unsigned",
          "Arguments": [
            {
              "Name": "equivocation_proof",
              "Type": "EquivocationProof<T::Hash, T::BlockNumber>"
            },
            {
              "Name": "key_owner_proof",
              "Type": "T::KeyOwnerProof"
            }
          ],
          "Documentations": [
            " Report voter equivocation/misbehavior. This method will verify the",
            " equivocation proof and validate the given key ownership proof",
            " against the extracted offender. If both are valid, the offence",
            " will be reported.",
            "",
            " This extrinsic must be called unsigned and it is expected that only",
            " block authors will call it (validated in `ValidateUnsigned`), as such",
            " if the block author is defined it will be defined as the equivocation",
            " reporter."
          ]
        },
        {
          "Name": "note_stalled",
          "Arguments": [
            {
              "Name": "delay",
              "Type": "T::BlockNumber"
            },
            {
              "Name": "best_finalized_block_number",
              "Type": "T::BlockNumber"
            }
          ],
          "Documentations": [
            " Note that the current authority set of the GRANDPA finality gadget has",
            " stalled. This will trigger a forced authority set change at the beginning",
            " of the next session, to be enacted `delay` blocks after that. The delay",
            " should be high enough to safely assume that the block signalling the",
            " forced change will not be re-orged (e.g. 1000 blocks). The GRANDPA voters",
            " will start the new authority set using the given finalized block as base.",
            " Only callable by root."
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " New authority set has been applied. \\[authority_set\\]"
          ],
          "Name": "NewAuthorities",
          "EventArgs": [
            "AuthorityList"
          ]
        },
        {
          "Documentations": [
            " Current authority set has been paused."
          ],
          "Name": "Paused",
          "EventArgs": [

          ]
        },
        {
          "Documentations": [
            " Current authority set has been resumed."
          ],
          "Name": "Resumed",
          "EventArgs": [

          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [
        {
          "Documentations": [
            " Attempt to signal GRANDPA pause when the authority set isn't live",
            " (either paused or already pending pause)."
          ],
          "Name": "PauseFailed"
        },
        {
          "Documentations": [
            " Attempt to signal GRANDPA resume when the authority set isn't paused",
            " (either live or already pending resume)."
          ],
          "Name": "ResumeFailed"
        },
        {
          "Documentations": [
            " Attempt to signal GRANDPA change with one already pending."
          ],
          "Name": "ChangePending"
        },
        {
          "Documentations": [
            " Cannot signal forced change so soon after last."
          ],
          "Name": "TooSoon"
        },
        {
          "Documentations": [
            " A key ownership proof provided as part of an equivocation report is invalid."
          ],
          "Name": "InvalidKeyOwnershipProof"
        },
        {
          "Documentations": [
            " An equivocation proof provided as part of an equivocation report is invalid."
          ],
          "Name": "InvalidEquivocationProof"
        },
        {
          "Documentations": [
            " A given equivocation report is valid but already previously reported."
          ],
          "Name": "DuplicateOffenceReport"
        }
      ]
    },
    {
      "Name": "ImOnline",
      "Index": 14,
      "Storage": {
        "Prefix": "ImOnline",
        "Items": [
          {
            "Name": "HeartbeatAfter",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::BlockNumber",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " The block number after which it's ok to send heartbeats in current session.",
              "",
              " At the beginning of each session we set this to a value that should",
              " fall roughly in the middle of the session duration.",
              " The idea is to first wait for the validators to produce a block",
              " in the current session, so that the heartbeat later on will not be necessary."
            ]
          },
          {
            "Name": "Keys",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::AuthorityId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current set of keys that may issue a heartbeat."
            ]
          },
          {
            "Name": "ReceivedHeartbeats",
            "Modifier": "Optional",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "SessionIndex",
              "Key2": "AuthIndex",
              "Value": "Vec<u8>",
              "IsLinked": true
            },
            "FallBack": "0x00",
            "Documentations": [
              " For each session index, we keep a mapping of `AuthIndex` to",
              " `offchain::OpaqueNetworkState`."
            ]
          },
          {
            "Name": "AuthoredBlocks",
            "Modifier": "Default",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "SessionIndex",
              "Key2": "ValidatorId<T>",
              "Value": "u32",
              "IsLinked": true
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " For each session index, we keep a mapping of `ValidatorId<T>` to the",
              " number of blocks authored by the given authority."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "heartbeat",
          "Arguments": [
            {
              "Name": "heartbeat",
              "Type": "Heartbeat<T::BlockNumber>"
            },
            {
              "Name": "_signature",
              "Type": "<T::AuthorityId as RuntimeAppPublic>::Signature"
            }
          ],
          "Documentations": [
            " # <weight>",
            " - Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len)",
            "   and E is length of `heartbeat.network_state.external_address`",
            "   - `O(K)`: decoding of length `K`",
            "   - `O(E)`: decoding/encoding of length `E`",
            " - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,",
            "   `ReceivedHeartbeats`",
            " - DbWrites: `ReceivedHeartbeats`",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A new heartbeat was received from `AuthorityId` \\[authority_id\\]"
          ],
          "Name": "HeartbeatReceived",
          "EventArgs": [
            "AuthorityId"
          ]
        },
        {
          "Documentations": [
            " At the end of the session, no offence was committed."
          ],
          "Name": "AllGood",
          "EventArgs": [

          ]
        },
        {
          "Documentations": [
            " At the end of the session, at least one validator was found to be \\[offline\\]."
          ],
          "Name": "SomeOffline",
          "EventArgs": [
            "Vec<IdentificationTuple>"
          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [
        {
          "Documentations": [
            " Non existent public key."
          ],
          "Name": "InvalidKey"
        },
        {
          "Documentations": [
            " Duplicated heartbeat."
          ],
          "Name": "DuplicatedHeartbeat"
        }
      ]
    },
    {
      "Name": "AuthorityDiscovery",
      "Index": 15,
      "Storage": null,
      "Calls": [

      ],
      "Events": null,
      "Consts": [

      ],
      "Errors": [

      ]
    },
    {
      "Name": "Democracy",
      "Index": 16,
      "Storage": {
        "Prefix": "Democracy",
        "Items": [
          {
            "Name": "PublicPropCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "PropIndex",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " The number of (public) proposals that have been made so far."
            ]
          },
          {
            "Name": "PublicProps",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<(PropIndex, T::Hash, T::AccountId)>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The public proposals. Unsorted. The second item is the proposal's hash."
            ]
          },
          {
            "Name": "DepositOf",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "PropIndex",
              "Key2": null,
              "Value": "(Vec<T::AccountId>, BalanceOf<T>)",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Those who have locked a deposit.",
              "",
              " TWOX-NOTE: Safe, as increasing integer keys are safe."
            ]
          },
          {
            "Name": "Preimages",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "PreimageStatus<T::AccountId, BalanceOf<T>, T::BlockNumber>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Map of hashes to the proposal preimage, along with who registered it and their deposit.",
              " The block number is the block at which it was deposited."
            ]
          },
          {
            "Name": "ReferendumCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "ReferendumIndex",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " The next free referendum index, aka the number of referenda started so far."
            ]
          },
          {
            "Name": "LowestUnbaked",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "ReferendumIndex",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " The lowest referendum index representing an unbaked referendum. Equal to",
              " `ReferendumCount` if there isn't a unbaked referendum."
            ]
          },
          {
            "Name": "ReferendumInfoOf",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "ReferendumIndex",
              "Key2": null,
              "Value": "ReferendumInfo<T::BlockNumber, T::Hash, BalanceOf<T>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Information concerning any given referendum.",
              "",
              " TWOX-NOTE: SAFE as indexes are not under an attackerâ??s control."
            ]
          },
          {
            "Name": "VotingOf",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "Voting<BalanceOf<T>, T::AccountId, T::BlockNumber>",
              "IsLinked": false
            },
            "FallBack": "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " All votes for a particular voter. We store the balance for the number of votes that we",
              " have recorded. The second item is the total amount of delegations, that will be added.",
              "",
              " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."
            ]
          },
          {
            "Name": "Locks",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "T::BlockNumber",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Accounts for which there are locks in action which may be removed at some point in the",
              " future. The value is the block number at which the lock expires and may be removed.",
              "",
              " TWOX-NOTE: OK â?? `AccountId` is a secure hash."
            ]
          },
          {
            "Name": "LastTabledWasExternal",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "bool",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " True if the last referendum tabled was submitted externally. False if it was a public",
              " proposal."
            ]
          },
          {
            "Name": "NextExternal",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "(T::Hash, VoteThreshold)",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The referendum to be tabled whenever it would be valid to table an external proposal.",
              " This happens when a referendum needs to be tabled and one of two conditions are met:",
              " - `LastTabledWasExternal` is `false`; or",
              " - `PublicProps` is empty."
            ]
          },
          {
            "Name": "Blacklist",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "(T::BlockNumber, Vec<T::AccountId>)",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A record of who vetoed what. Maps proposal hash to a possible existent block number",
              " (until when it may not be resubmitted) and who vetoed it."
            ]
          },
          {
            "Name": "Cancellations",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "bool",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Record of all proposals that have been subject to emergency cancellation."
            ]
          },
          {
            "Name": "StorageVersion",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Releases",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Storage version of the pallet.",
              "",
              " New networks start with last version."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "propose",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            },
            {
              "Name": "value",
              "Type": "Compact<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Propose a sensitive action to be taken.",
            "",
            " The dispatch origin of this call must be _Signed_ and the sender must",
            " have funds to cover the deposit.",
            "",
            " - `proposal_hash`: The hash of the proposal preimage.",
            " - `value`: The amount of deposit (must be at least `MinimumDeposit`).",
            "",
            " Emits `Proposed`.",
            "",
            " Weight: `O(p)`"
          ]
        },
        {
          "Name": "second",
          "Arguments": [
            {
              "Name": "proposal",
              "Type": "Compact<PropIndex>"
            },
            {
              "Name": "seconds_upper_bound",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Signals agreement with a particular proposal.",
            "",
            " The dispatch origin of this call must be _Signed_ and the sender",
            " must have funds to cover the deposit, equal to the original deposit.",
            "",
            " - `proposal`: The index of the proposal to second.",
            " - `seconds_upper_bound`: an upper bound on the current number of seconds on this",
            "   proposal. Extrinsic is weighted according to this value with no refund.",
            "",
            " Weight: `O(S)` where S is the number of seconds a proposal already has."
          ]
        },
        {
          "Name": "vote",
          "Arguments": [
            {
              "Name": "ref_index",
              "Type": "Compact<ReferendumIndex>"
            },
            {
              "Name": "vote",
              "Type": "AccountVote<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;",
            " otherwise it is a vote to keep the status quo.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `ref_index`: The index of the referendum to vote for.",
            " - `vote`: The vote configuration.",
            "",
            " Weight: `O(R)` where R is the number of referendums the voter has voted on."
          ]
        },
        {
          "Name": "emergency_cancel",
          "Arguments": [
            {
              "Name": "ref_index",
              "Type": "ReferendumIndex"
            }
          ],
          "Documentations": [
            " Schedule an emergency cancellation of a referendum. Cannot happen twice to the same",
            " referendum.",
            "",
            " The dispatch origin of this call must be `CancellationOrigin`.",
            "",
            " -`ref_index`: The index of the referendum to cancel.",
            "",
            " Weight: `O(1)`."
          ]
        },
        {
          "Name": "external_propose",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Schedule a referendum to be tabled once it is legal to schedule an external",
            " referendum.",
            "",
            " The dispatch origin of this call must be `ExternalOrigin`.",
            "",
            " - `proposal_hash`: The preimage hash of the proposal.",
            "",
            " Weight: `O(V)` with V number of vetoers in the blacklist of proposal.",
            "   Decoding vec of length V. Charged as maximum"
          ]
        },
        {
          "Name": "external_propose_majority",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Schedule a majority-carries referendum to be tabled next once it is legal to schedule",
            " an external referendum.",
            "",
            " The dispatch of this call must be `ExternalMajorityOrigin`.",
            "",
            " - `proposal_hash`: The preimage hash of the proposal.",
            "",
            " Unlike `external_propose`, blacklisting has no effect on this and it may replace a",
            " pre-scheduled `external_propose` call.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "external_propose_default",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Schedule a negative-turnout-bias referendum to be tabled next once it is legal to",
            " schedule an external referendum.",
            "",
            " The dispatch of this call must be `ExternalDefaultOrigin`.",
            "",
            " - `proposal_hash`: The preimage hash of the proposal.",
            "",
            " Unlike `external_propose`, blacklisting has no effect on this and it may replace a",
            " pre-scheduled `external_propose` call.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "fast_track",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            },
            {
              "Name": "voting_period",
              "Type": "T::BlockNumber"
            },
            {
              "Name": "delay",
              "Type": "T::BlockNumber"
            }
          ],
          "Documentations": [
            " Schedule the currently externally-proposed majority-carries referendum to be tabled",
            " immediately. If there is no externally-proposed referendum currently, or if there is one",
            " but it is not a majority-carries referendum then it fails.",
            "",
            " The dispatch of this call must be `FastTrackOrigin`.",
            "",
            " - `proposal_hash`: The hash of the current external proposal.",
            " - `voting_period`: The period that is allowed for voting on this proposal. Increased to",
            "   `FastTrackVotingPeriod` if too low.",
            " - `delay`: The number of block after voting has ended in approval and this should be",
            "   enacted. This doesn't have a minimum amount.",
            "",
            " Emits `Started`.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "veto_external",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Veto and blacklist the external proposal hash.",
            "",
            " The dispatch origin of this call must be `VetoOrigin`.",
            "",
            " - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.",
            "",
            " Emits `Vetoed`.",
            "",
            " Weight: `O(V + log(V))` where V is number of `existing vetoers`"
          ]
        },
        {
          "Name": "cancel_referendum",
          "Arguments": [
            {
              "Name": "ref_index",
              "Type": "Compact<ReferendumIndex>"
            }
          ],
          "Documentations": [
            " Remove a referendum.",
            "",
            " The dispatch origin of this call must be _Root_.",
            "",
            " - `ref_index`: The index of the referendum to cancel.",
            "",
            " # Weight: `O(1)`."
          ]
        },
        {
          "Name": "cancel_queued",
          "Arguments": [
            {
              "Name": "which",
              "Type": "ReferendumIndex"
            }
          ],
          "Documentations": [
            " Cancel a proposal queued for enactment.",
            "",
            " The dispatch origin of this call must be _Root_.",
            "",
            " - `which`: The index of the referendum to cancel.",
            "",
            " Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`."
          ]
        },
        {
          "Name": "delegate",
          "Arguments": [
            {
              "Name": "to",
              "Type": "T::AccountId"
            },
            {
              "Name": "conviction",
              "Type": "Conviction"
            },
            {
              "Name": "balance",
              "Type": "BalanceOf<T>"
            }
          ],
          "Documentations": [
            " Delegate the voting power (with some given conviction) of the sending account.",
            "",
            " The balance delegated is locked for as long as it's delegated, and thereafter for the",
            " time appropriate for the conviction's lock period.",
            "",
            " The dispatch origin of this call must be _Signed_, and the signing account must either:",
            "   - be delegating already; or",
            "   - have no voting activity (if there is, then it will need to be removed/consolidated",
            "     through `reap_vote` or `unvote`).",
            "",
            " - `to`: The account whose voting the `target` account's voting power will follow.",
            " - `conviction`: The conviction that will be attached to the delegated votes. When the",
            "   account is undelegated, the funds will be locked for the corresponding period.",
            " - `balance`: The amount of the account's balance to be used in delegating. This must",
            "   not be more than the account's current balance.",
            "",
            " Emits `Delegated`.",
            "",
            " Weight: `O(R)` where R is the number of referendums the voter delegating to has",
            "   voted on. Weight is charged as if maximum votes."
          ]
        },
        {
          "Name": "undelegate",
          "Arguments": [

          ],
          "Documentations": [
            " Undelegate the voting power of the sending account.",
            "",
            " Tokens may be unlocked following once an amount of time consistent with the lock period",
            " of the conviction with which the delegation was issued.",
            "",
            " The dispatch origin of this call must be _Signed_ and the signing account must be",
            " currently delegating.",
            "",
            " Emits `Undelegated`.",
            "",
            " Weight: `O(R)` where R is the number of referendums the voter delegating to has",
            "   voted on. Weight is charged as if maximum votes."
          ]
        },
        {
          "Name": "clear_public_proposals",
          "Arguments": [

          ],
          "Documentations": [
            " Clears all public proposals.",
            "",
            " The dispatch origin of this call must be _Root_.",
            "",
            " Weight: `O(1)`."
          ]
        },
        {
          "Name": "note_preimage",
          "Arguments": [
            {
              "Name": "encoded_proposal",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Register the preimage for an upcoming proposal. This doesn't require the proposal to be",
            " in the dispatch queue but does require a deposit, returned once enacted.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `encoded_proposal`: The preimage of a proposal.",
            "",
            " Emits `PreimageNoted`.",
            "",
            " Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."
          ]
        },
        {
          "Name": "note_preimage_operational",
          "Arguments": [
            {
              "Name": "encoded_proposal",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Same as `note_preimage` but origin is `OperationalPreimageOrigin`."
          ]
        },
        {
          "Name": "note_imminent_preimage",
          "Arguments": [
            {
              "Name": "encoded_proposal",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Register the preimage for an upcoming proposal. This requires the proposal to be",
            " in the dispatch queue. No deposit is needed. When this call is successful, i.e.",
            " the preimage has not been uploaded before and matches some imminent proposal,",
            " no fee is paid.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `encoded_proposal`: The preimage of a proposal.",
            "",
            " Emits `PreimageNoted`.",
            "",
            " Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."
          ]
        },
        {
          "Name": "note_imminent_preimage_operational",
          "Arguments": [
            {
              "Name": "encoded_proposal",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`."
          ]
        },
        {
          "Name": "reap_preimage",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            },
            {
              "Name": "proposal_len_upper_bound",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Remove an expired proposal preimage and collect the deposit.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `proposal_hash`: The preimage hash of a proposal.",
            " - `proposal_length_upper_bound`: an upper bound on length of the proposal.",
            "   Extrinsic is weighted according to this value with no refund.",
            "",
            " This will only work after `VotingPeriod` blocks from the time that the preimage was",
            " noted, if it's the same account doing it. If it's a different account, then it'll only",
            " work an additional `EnactmentPeriod` later.",
            "",
            " Emits `PreimageReaped`.",
            "",
            " Weight: `O(D)` where D is length of proposal."
          ]
        },
        {
          "Name": "unlock",
          "Arguments": [
            {
              "Name": "target",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Unlock tokens that have an expired lock.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `target`: The account to remove the lock on.",
            "",
            " Weight: `O(R)` with R number of vote of target."
          ]
        },
        {
          "Name": "remove_vote",
          "Arguments": [
            {
              "Name": "index",
              "Type": "ReferendumIndex"
            }
          ],
          "Documentations": [
            " Remove a vote for a referendum.",
            "",
            " If:",
            " - the referendum was cancelled, or",
            " - the referendum is ongoing, or",
            " - the referendum has ended such that",
            "   - the vote of the account was in opposition to the result; or",
            "   - there was no conviction to the account's vote; or",
            "   - the account made a split vote",
            " ...then the vote is removed cleanly and a following call to `unlock` may result in more",
            " funds being available.",
            "",
            " If, however, the referendum has ended and:",
            " - it finished corresponding to the vote of the account, and",
            " - the account made a standard vote with conviction, and",
            " - the lock period of the conviction is not over",
            " ...then the lock will be aggregated into the overall account's lock, which may involve",
            " *overlocking* (where the two locks are combined into a single lock that is the maximum",
            " of both the amount locked and the time is it locked for).",
            "",
            " The dispatch origin of this call must be _Signed_, and the signer must have a vote",
            " registered for referendum `index`.",
            "",
            " - `index`: The index of referendum of the vote to be removed.",
            "",
            " Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.",
            "   Weight is calculated for the maximum number of vote."
          ]
        },
        {
          "Name": "remove_other_vote",
          "Arguments": [
            {
              "Name": "target",
              "Type": "T::AccountId"
            },
            {
              "Name": "index",
              "Type": "ReferendumIndex"
            }
          ],
          "Documentations": [
            " Remove a vote for a referendum.",
            "",
            " If the `target` is equal to the signer, then this function is exactly equivalent to",
            " `remove_vote`. If not equal to the signer, then the vote must have expired,",
            " either because the referendum was cancelled, because the voter lost the referendum or",
            " because the conviction period is over.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `target`: The account of the vote to be removed; this account must have voted for",
            "   referendum `index`.",
            " - `index`: The index of referendum of the vote to be removed.",
            "",
            " Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.",
            "   Weight is calculated for the maximum number of vote."
          ]
        },
        {
          "Name": "enact_proposal",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            },
            {
              "Name": "index",
              "Type": "ReferendumIndex"
            }
          ],
          "Documentations": [
            " Enact a proposal from a referendum. For now we just make the weight be the maximum."
          ]
        },
        {
          "Name": "blacklist",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            },
            {
              "Name": "maybe_ref_index",
              "Type": "Option<ReferendumIndex>"
            }
          ],
          "Documentations": [
            " Permanently place a proposal into the blacklist. This prevents it from ever being",
            " proposed again.",
            "",
            " If called on a queued public or external proposal, then this will result in it being",
            " removed. If the `ref_index` supplied is an active referendum with the proposal hash,",
            " then it will be cancelled.",
            "",
            " The dispatch origin of this call must be `BlacklistOrigin`.",
            "",
            " - `proposal_hash`: The proposal hash to blacklist permanently.",
            " - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be",
            " cancelled.",
            "",
            " Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a",
            "   reasonable value)."
          ]
        },
        {
          "Name": "cancel_proposal",
          "Arguments": [
            {
              "Name": "prop_index",
              "Type": "Compact<PropIndex>"
            }
          ],
          "Documentations": [
            " Remove a proposal.",
            "",
            " The dispatch origin of this call must be `CancelProposalOrigin`.",
            "",
            " - `prop_index`: The index of the proposal to cancel.",
            "",
            " Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A motion has been proposed by a public account. \\[proposal_index, deposit\\]"
          ],
          "Name": "Proposed",
          "EventArgs": [
            "PropIndex",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A public proposal has been tabled for referendum vote. \\[proposal_index, deposit, depositors\\]"
          ],
          "Name": "Tabled",
          "EventArgs": [
            "PropIndex",
            "Balance",
            "Vec<AccountId>"
          ]
        },
        {
          "Documentations": [
            " An external proposal has been tabled."
          ],
          "Name": "ExternalTabled",
          "EventArgs": [

          ]
        },
        {
          "Documentations": [
            " A referendum has begun. \\[ref_index, threshold\\]"
          ],
          "Name": "Started",
          "EventArgs": [
            "ReferendumIndex",
            "VoteThreshold"
          ]
        },
        {
          "Documentations": [
            " A proposal has been approved by referendum. \\[ref_index\\]"
          ],
          "Name": "Passed",
          "EventArgs": [
            "ReferendumIndex"
          ]
        },
        {
          "Documentations": [
            " A proposal has been rejected by referendum. \\[ref_index\\]"
          ],
          "Name": "NotPassed",
          "EventArgs": [
            "ReferendumIndex"
          ]
        },
        {
          "Documentations": [
            " A referendum has been cancelled. \\[ref_index\\]"
          ],
          "Name": "Cancelled",
          "EventArgs": [
            "ReferendumIndex"
          ]
        },
        {
          "Documentations": [
            " A proposal has been enacted. \\[ref_index, is_ok\\]"
          ],
          "Name": "Executed",
          "EventArgs": [
            "ReferendumIndex",
            "bool"
          ]
        },
        {
          "Documentations": [
            " An account has delegated their vote to another account. \\[who, target\\]"
          ],
          "Name": "Delegated",
          "EventArgs": [
            "AccountId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " An \\[account\\] has cancelled a previous delegation operation."
          ],
          "Name": "Undelegated",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " An external proposal has been vetoed. \\[who, proposal_hash, until\\]"
          ],
          "Name": "Vetoed",
          "EventArgs": [
            "AccountId",
            "Hash",
            "BlockNumber"
          ]
        },
        {
          "Documentations": [
            " A proposal's preimage was noted, and the deposit taken. \\[proposal_hash, who, deposit\\]"
          ],
          "Name": "PreimageNoted",
          "EventArgs": [
            "Hash",
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A proposal preimage was removed and used (the deposit was returned).",
            " \\[proposal_hash, provider, deposit\\]"
          ],
          "Name": "PreimageUsed",
          "EventArgs": [
            "Hash",
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A proposal could not be executed because its preimage was invalid.",
            " \\[proposal_hash, ref_index\\]"
          ],
          "Name": "PreimageInvalid",
          "EventArgs": [
            "Hash",
            "ReferendumIndex"
          ]
        },
        {
          "Documentations": [
            " A proposal could not be executed because its preimage was missing.",
            " \\[proposal_hash, ref_index\\]"
          ],
          "Name": "PreimageMissing",
          "EventArgs": [
            "Hash",
            "ReferendumIndex"
          ]
        },
        {
          "Documentations": [
            " A registered preimage was removed and the deposit collected by the reaper.",
            " \\[proposal_hash, provider, deposit, reaper\\]"
          ],
          "Name": "PreimageReaped",
          "EventArgs": [
            "Hash",
            "AccountId",
            "Balance",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " An \\[account\\] has been unlocked successfully."
          ],
          "Name": "Unlocked",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A proposal \\[hash\\] has been blacklisted permanently."
          ],
          "Name": "Blacklisted",
          "EventArgs": [
            "Hash"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "EnactmentPeriod",
          "Type": "T::BlockNumber",
          "Value": "0x002F0D00",
          "Documentations": [
            " The minimum period of locking and the period between a proposal being approved and enacted.",
            "",
            " It should generally be a little more than the unstake period to ensure that",
            " voting stakers have an opportunity to remove themselves from the system in the case where",
            " they are on the losing side of a vote."
          ]
        },
        {
          "Name": "LaunchPeriod",
          "Type": "T::BlockNumber",
          "Value": "0x004E0C00",
          "Documentations": [
            " How often (in blocks) new public referenda are launched."
          ]
        },
        {
          "Name": "VotingPeriod",
          "Type": "T::BlockNumber",
          "Value": "0x004E0C00",
          "Documentations": [
            " How often (in blocks) to check for new votes."
          ]
        },
        {
          "Name": "MinimumDeposit",
          "Type": "BalanceOf<T>",
          "Value": "0x0000C16FF28623000000000000000000",
          "Documentations": [
            " The minimum amount to be used as a deposit for a public referendum proposal."
          ]
        },
        {
          "Name": "FastTrackVotingPeriod",
          "Type": "T::BlockNumber",
          "Value": "0x80510100",
          "Documentations": [
            " Minimum voting period allowed for an emergency referendum."
          ]
        },
        {
          "Name": "CooloffPeriod",
          "Type": "T::BlockNumber",
          "Value": "0x004E0C00",
          "Documentations": [
            " Period in blocks where an external proposal may not be re-submitted after being vetoed."
          ]
        },
        {
          "Name": "PreimageByteDeposit",
          "Type": "BalanceOf<T>",
          "Value": "0x0010A5D4E80000000000000000000000",
          "Documentations": [
            " The amount of balance that must be deposited per byte of preimage stored."
          ]
        },
        {
          "Name": "MaxVotes",
          "Type": "u32",
          "Value": "0x64000000",
          "Documentations": [
            " The maximum number of votes for an account."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " Value too low"
          ],
          "Name": "ValueLow"
        },
        {
          "Documentations": [
            " Proposal does not exist"
          ],
          "Name": "ProposalMissing"
        },
        {
          "Documentations": [
            " Unknown index"
          ],
          "Name": "BadIndex"
        },
        {
          "Documentations": [
            " Cannot cancel the same proposal twice"
          ],
          "Name": "AlreadyCanceled"
        },
        {
          "Documentations": [
            " Proposal already made"
          ],
          "Name": "DuplicateProposal"
        },
        {
          "Documentations": [
            " Proposal still blacklisted"
          ],
          "Name": "ProposalBlacklisted"
        },
        {
          "Documentations": [
            " Next external proposal not simple majority"
          ],
          "Name": "NotSimpleMajority"
        },
        {
          "Documentations": [
            " Invalid hash"
          ],
          "Name": "InvalidHash"
        },
        {
          "Documentations": [
            " No external proposal"
          ],
          "Name": "NoProposal"
        },
        {
          "Documentations": [
            " Identity may not veto a proposal twice"
          ],
          "Name": "AlreadyVetoed"
        },
        {
          "Documentations": [
            " Not delegated"
          ],
          "Name": "NotDelegated"
        },
        {
          "Documentations": [
            " Preimage already noted"
          ],
          "Name": "DuplicatePreimage"
        },
        {
          "Documentations": [
            " Not imminent"
          ],
          "Name": "NotImminent"
        },
        {
          "Documentations": [
            " Too early"
          ],
          "Name": "TooEarly"
        },
        {
          "Documentations": [
            " Imminent"
          ],
          "Name": "Imminent"
        },
        {
          "Documentations": [
            " Preimage not found"
          ],
          "Name": "PreimageMissing"
        },
        {
          "Documentations": [
            " Vote given for invalid referendum"
          ],
          "Name": "ReferendumInvalid"
        },
        {
          "Documentations": [
            " Invalid preimage"
          ],
          "Name": "PreimageInvalid"
        },
        {
          "Documentations": [
            " No proposals waiting"
          ],
          "Name": "NoneWaiting"
        },
        {
          "Documentations": [
            " The target account does not have a lock."
          ],
          "Name": "NotLocked"
        },
        {
          "Documentations": [
            " The lock on the account to be unlocked has not yet expired."
          ],
          "Name": "NotExpired"
        },
        {
          "Documentations": [
            " The given account did not vote on the referendum."
          ],
          "Name": "NotVoter"
        },
        {
          "Documentations": [
            " The actor has no permission to conduct the action."
          ],
          "Name": "NoPermission"
        },
        {
          "Documentations": [
            " The account is already delegating."
          ],
          "Name": "AlreadyDelegating"
        },
        {
          "Documentations": [
            " An unexpected integer overflow occurred."
          ],
          "Name": "Overflow"
        },
        {
          "Documentations": [
            " An unexpected integer underflow occurred."
          ],
          "Name": "Underflow"
        },
        {
          "Documentations": [
            " Too high a balance was provided that the account cannot afford."
          ],
          "Name": "InsufficientFunds"
        },
        {
          "Documentations": [
            " The account is not currently delegating."
          ],
          "Name": "NotDelegating"
        },
        {
          "Documentations": [
            " The account currently has votes attached to it and the operation cannot succeed until",
            " these are removed, either through `unvote` or `reap_vote`."
          ],
          "Name": "VotesExist"
        },
        {
          "Documentations": [
            " The instant referendum origin is currently disallowed."
          ],
          "Name": "InstantNotAllowed"
        },
        {
          "Documentations": [
            " Delegation to oneself makes no sense."
          ],
          "Name": "Nonsense"
        },
        {
          "Documentations": [
            " Invalid upper bound."
          ],
          "Name": "WrongUpperBound"
        },
        {
          "Documentations": [
            " Maximum number of votes reached."
          ],
          "Name": "MaxVotesReached"
        },
        {
          "Documentations": [
            " The provided witness data is wrong."
          ],
          "Name": "InvalidWitness"
        },
        {
          "Documentations": [
            " Maximum number of proposals reached."
          ],
          "Name": "TooManyProposals"
        }
      ]
    },
    {
      "Name": "Council",
      "Index": 17,
      "Storage": {
        "Prefix": "Instance1Collective",
        "Items": [
          {
            "Name": "Proposals",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::Hash>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The hashes of the active proposals."
            ]
          },
          {
            "Name": "ProposalOf",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "<T as Config<I>>::Proposal",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Actual proposal for a given hash, if it's current."
            ]
          },
          {
            "Name": "Voting",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "Votes<T::AccountId, T::BlockNumber>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Votes on a given proposal, if it is ongoing."
            ]
          },
          {
            "Name": "ProposalCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " Proposals so far."
            ]
          },
          {
            "Name": "Members",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current members of the collective. This is stored sorted (just by value)."
            ]
          },
          {
            "Name": "Prime",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The prime member that helps determine the default vote behavior in case of absentations."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "set_members",
          "Arguments": [
            {
              "Name": "new_members",
              "Type": "Vec<T::AccountId>"
            },
            {
              "Name": "prime",
              "Type": "Option<T::AccountId>"
            },
            {
              "Name": "old_count",
              "Type": "MemberCount"
            }
          ],
          "Documentations": [
            " Set the collective's membership.",
            "",
            " - `new_members`: The new member list. Be nice to the chain and provide it sorted.",
            " - `prime`: The prime member whose vote sets the default.",
            " - `old_count`: The upper bound for the previous number of members in storage.",
            "                Used for weight estimation.",
            "",
            " Requires root origin.",
            "",
            " NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but",
            "       the weight estimations rely on it to estimate dispatchable weight.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(MP + N)` where:",
            "   - `M` old-members-count (code- and governance-bounded)",
            "   - `N` new-members-count (code- and governance-bounded)",
            "   - `P` proposals-count (code-bounded)",
            " - DB:",
            "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members",
            "   - 1 storage read (codec `O(P)`) for reading the proposals",
            "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal",
            "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one",
            " # </weight>"
          ]
        },
        {
          "Name": "execute",
          "Arguments": [
            {
              "Name": "proposal",
              "Type": "Box<<T as Config<I>>::Proposal>"
            },
            {
              "Name": "length_bound",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Dispatch a proposal from a member using the `Member` origin.",
            "",
            " Origin must be a member of the collective.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`",
            " - DB: 1 read (codec `O(M)`) + DB access of `proposal`",
            " - 1 event",
            " # </weight>"
          ]
        },
        {
          "Name": "propose",
          "Arguments": [
            {
              "Name": "threshold",
              "Type": "Compact<MemberCount>"
            },
            {
              "Name": "proposal",
              "Type": "Box<<T as Config<I>>::Proposal>"
            },
            {
              "Name": "length_bound",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Add a new proposal to either be voted on or executed directly.",
            "",
            " Requires the sender to be member.",
            "",
            " `threshold` determines whether `proposal` is executed directly (`threshold < 2`)",
            " or put up for voting.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(B + M + P1)` or `O(B + M + P2)` where:",
            "   - `B` is `proposal` size in bytes (length-fee-bounded)",
            "   - `M` is members-count (code- and governance-bounded)",
            "   - branching is influenced by `threshold` where:",
            "     - `P1` is proposal execution complexity (`threshold < 2`)",
            "     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)",
            " - DB:",
            "   - 1 storage read `is_member` (codec `O(M)`)",
            "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)",
            "   - DB accesses influenced by `threshold`:",
            "     - EITHER storage accesses done by `proposal` (`threshold < 2`)",
            "     - OR proposal insertion (`threshold <= 2`)",
            "       - 1 storage mutation `Proposals` (codec `O(P2)`)",
            "       - 1 storage mutation `ProposalCount` (codec `O(1)`)",
            "       - 1 storage write `ProposalOf` (codec `O(B)`)",
            "       - 1 storage write `Voting` (codec `O(M)`)",
            "   - 1 event",
            " # </weight>"
          ]
        },
        {
          "Name": "vote",
          "Arguments": [
            {
              "Name": "proposal",
              "Type": "T::Hash"
            },
            {
              "Name": "index",
              "Type": "Compact<ProposalIndex>"
            },
            {
              "Name": "approve",
              "Type": "bool"
            }
          ],
          "Documentations": [
            " Add an aye or nay vote for the sender to the given proposal.",
            "",
            " Requires the sender to be a member.",
            "",
            " Transaction fees will be waived if the member is voting on any particular proposal",
            " for the first time and the call is successful. Subsequent vote changes will charge a fee.",
            " # <weight>",
            " ## Weight",
            " - `O(M)` where `M` is members-count (code- and governance-bounded)",
            " - DB:",
            "   - 1 storage read `Members` (codec `O(M)`)",
            "   - 1 storage mutation `Voting` (codec `O(M)`)",
            " - 1 event",
            " # </weight>"
          ]
        },
        {
          "Name": "close",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            },
            {
              "Name": "index",
              "Type": "Compact<ProposalIndex>"
            },
            {
              "Name": "proposal_weight_bound",
              "Type": "Compact<Weight>"
            },
            {
              "Name": "length_bound",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Close a vote that is either approved, disapproved or whose voting period has ended.",
            "",
            " May be called by any signed account in order to finish voting and close the proposal.",
            "",
            " If called before the end of the voting period it will only close the vote if it is",
            " has enough votes to be approved or disapproved.",
            "",
            " If called after the end of the voting period abstentions are counted as rejections",
            " unless there is a prime member set and the prime member cast an approval.",
            "",
            " If the close operation completes successfully with disapproval, the transaction fee will",
            " be waived. Otherwise execution of the approved operation will be charged to the caller.",
            "",
            " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.",
            " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via",
            "                   `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(B + M + P1 + P2)` where:",
            "   - `B` is `proposal` size in bytes (length-fee-bounded)",
            "   - `M` is members-count (code- and governance-bounded)",
            "   - `P1` is the complexity of `proposal` preimage.",
            "   - `P2` is proposal-count (code-bounded)",
            " - DB:",
            "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)",
            "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)",
            "  - any mutations done while executing `proposal` (`P1`)",
            " - up to 3 events",
            " # </weight>"
          ]
        },
        {
          "Name": "disapprove_proposal",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Disapprove a proposal, close, and remove it from the system, regardless of its current state.",
            "",
            " Must be called by the Root origin.",
            "",
            " Parameters:",
            " * `proposal_hash`: The hash of the proposal that should be disapproved.",
            "",
            " # <weight>",
            " Complexity: O(P) where P is the number of max proposals",
            " DB Weight:",
            " * Reads: Proposals",
            " * Writes: Voting, Proposals, ProposalOf",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A motion (given hash) has been proposed (by given account) with a threshold (given",
            " `MemberCount`).",
            " \\[account, proposal_index, proposal_hash, threshold\\]"
          ],
          "Name": "Proposed",
          "EventArgs": [
            "AccountId",
            "ProposalIndex",
            "Hash",
            "MemberCount"
          ]
        },
        {
          "Documentations": [
            " A motion (given hash) has been voted on by given account, leaving",
            " a tally (yes votes and no votes given respectively as `MemberCount`).",
            " \\[account, proposal_hash, voted, yes, no\\]"
          ],
          "Name": "Voted",
          "EventArgs": [
            "AccountId",
            "Hash",
            "bool",
            "MemberCount",
            "MemberCount"
          ]
        },
        {
          "Documentations": [
            " A motion was approved by the required threshold.",
            " \\[proposal_hash\\]"
          ],
          "Name": "Approved",
          "EventArgs": [
            "Hash"
          ]
        },
        {
          "Documentations": [
            " A motion was not approved by the required threshold.",
            " \\[proposal_hash\\]"
          ],
          "Name": "Disapproved",
          "EventArgs": [
            "Hash"
          ]
        },
        {
          "Documentations": [
            " A motion was executed; result will be `Ok` if it returned without error.",
            " \\[proposal_hash, result\\]"
          ],
          "Name": "Executed",
          "EventArgs": [
            "Hash",
            "DispatchResult"
          ]
        },
        {
          "Documentations": [
            " A single member did some action; result will be `Ok` if it returned without error.",
            " \\[proposal_hash, result\\]"
          ],
          "Name": "MemberExecuted",
          "EventArgs": [
            "Hash",
            "DispatchResult"
          ]
        },
        {
          "Documentations": [
            " A proposal was closed because its threshold was reached or after its duration was up.",
            " \\[proposal_hash, yes, no\\]"
          ],
          "Name": "Closed",
          "EventArgs": [
            "Hash",
            "MemberCount",
            "MemberCount"
          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [
        {
          "Documentations": [
            " Account is not a member"
          ],
          "Name": "NotMember"
        },
        {
          "Documentations": [
            " Duplicate proposals not allowed"
          ],
          "Name": "DuplicateProposal"
        },
        {
          "Documentations": [
            " Proposal must exist"
          ],
          "Name": "ProposalMissing"
        },
        {
          "Documentations": [
            " Mismatched index"
          ],
          "Name": "WrongIndex"
        },
        {
          "Documentations": [
            " Duplicate vote ignored"
          ],
          "Name": "DuplicateVote"
        },
        {
          "Documentations": [
            " Members are already initialized!"
          ],
          "Name": "AlreadyInitialized"
        },
        {
          "Documentations": [
            " The close call was made too early, before the end of the voting."
          ],
          "Name": "TooEarly"
        },
        {
          "Documentations": [
            " There can only be a maximum of `MaxProposals` active proposals."
          ],
          "Name": "TooManyProposals"
        },
        {
          "Documentations": [
            " The given weight bound for the proposal was too low."
          ],
          "Name": "WrongProposalWeight"
        },
        {
          "Documentations": [
            " The given length bound for the proposal was too low."
          ],
          "Name": "WrongProposalLength"
        }
      ]
    },
    {
      "Name": "TechnicalCommittee",
      "Index": 18,
      "Storage": {
        "Prefix": "Instance2Collective",
        "Items": [
          {
            "Name": "Proposals",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::Hash>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The hashes of the active proposals."
            ]
          },
          {
            "Name": "ProposalOf",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "<T as Config<I>>::Proposal",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Actual proposal for a given hash, if it's current."
            ]
          },
          {
            "Name": "Voting",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "Votes<T::AccountId, T::BlockNumber>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Votes on a given proposal, if it is ongoing."
            ]
          },
          {
            "Name": "ProposalCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " Proposals so far."
            ]
          },
          {
            "Name": "Members",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current members of the collective. This is stored sorted (just by value)."
            ]
          },
          {
            "Name": "Prime",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The prime member that helps determine the default vote behavior in case of absentations."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "set_members",
          "Arguments": [
            {
              "Name": "new_members",
              "Type": "Vec<T::AccountId>"
            },
            {
              "Name": "prime",
              "Type": "Option<T::AccountId>"
            },
            {
              "Name": "old_count",
              "Type": "MemberCount"
            }
          ],
          "Documentations": [
            " Set the collective's membership.",
            "",
            " - `new_members`: The new member list. Be nice to the chain and provide it sorted.",
            " - `prime`: The prime member whose vote sets the default.",
            " - `old_count`: The upper bound for the previous number of members in storage.",
            "                Used for weight estimation.",
            "",
            " Requires root origin.",
            "",
            " NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but",
            "       the weight estimations rely on it to estimate dispatchable weight.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(MP + N)` where:",
            "   - `M` old-members-count (code- and governance-bounded)",
            "   - `N` new-members-count (code- and governance-bounded)",
            "   - `P` proposals-count (code-bounded)",
            " - DB:",
            "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members",
            "   - 1 storage read (codec `O(P)`) for reading the proposals",
            "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal",
            "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one",
            " # </weight>"
          ]
        },
        {
          "Name": "execute",
          "Arguments": [
            {
              "Name": "proposal",
              "Type": "Box<<T as Config<I>>::Proposal>"
            },
            {
              "Name": "length_bound",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Dispatch a proposal from a member using the `Member` origin.",
            "",
            " Origin must be a member of the collective.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`",
            " - DB: 1 read (codec `O(M)`) + DB access of `proposal`",
            " - 1 event",
            " # </weight>"
          ]
        },
        {
          "Name": "propose",
          "Arguments": [
            {
              "Name": "threshold",
              "Type": "Compact<MemberCount>"
            },
            {
              "Name": "proposal",
              "Type": "Box<<T as Config<I>>::Proposal>"
            },
            {
              "Name": "length_bound",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Add a new proposal to either be voted on or executed directly.",
            "",
            " Requires the sender to be member.",
            "",
            " `threshold` determines whether `proposal` is executed directly (`threshold < 2`)",
            " or put up for voting.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(B + M + P1)` or `O(B + M + P2)` where:",
            "   - `B` is `proposal` size in bytes (length-fee-bounded)",
            "   - `M` is members-count (code- and governance-bounded)",
            "   - branching is influenced by `threshold` where:",
            "     - `P1` is proposal execution complexity (`threshold < 2`)",
            "     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)",
            " - DB:",
            "   - 1 storage read `is_member` (codec `O(M)`)",
            "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)",
            "   - DB accesses influenced by `threshold`:",
            "     - EITHER storage accesses done by `proposal` (`threshold < 2`)",
            "     - OR proposal insertion (`threshold <= 2`)",
            "       - 1 storage mutation `Proposals` (codec `O(P2)`)",
            "       - 1 storage mutation `ProposalCount` (codec `O(1)`)",
            "       - 1 storage write `ProposalOf` (codec `O(B)`)",
            "       - 1 storage write `Voting` (codec `O(M)`)",
            "   - 1 event",
            " # </weight>"
          ]
        },
        {
          "Name": "vote",
          "Arguments": [
            {
              "Name": "proposal",
              "Type": "T::Hash"
            },
            {
              "Name": "index",
              "Type": "Compact<ProposalIndex>"
            },
            {
              "Name": "approve",
              "Type": "bool"
            }
          ],
          "Documentations": [
            " Add an aye or nay vote for the sender to the given proposal.",
            "",
            " Requires the sender to be a member.",
            "",
            " Transaction fees will be waived if the member is voting on any particular proposal",
            " for the first time and the call is successful. Subsequent vote changes will charge a fee.",
            " # <weight>",
            " ## Weight",
            " - `O(M)` where `M` is members-count (code- and governance-bounded)",
            " - DB:",
            "   - 1 storage read `Members` (codec `O(M)`)",
            "   - 1 storage mutation `Voting` (codec `O(M)`)",
            " - 1 event",
            " # </weight>"
          ]
        },
        {
          "Name": "close",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            },
            {
              "Name": "index",
              "Type": "Compact<ProposalIndex>"
            },
            {
              "Name": "proposal_weight_bound",
              "Type": "Compact<Weight>"
            },
            {
              "Name": "length_bound",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Close a vote that is either approved, disapproved or whose voting period has ended.",
            "",
            " May be called by any signed account in order to finish voting and close the proposal.",
            "",
            " If called before the end of the voting period it will only close the vote if it is",
            " has enough votes to be approved or disapproved.",
            "",
            " If called after the end of the voting period abstentions are counted as rejections",
            " unless there is a prime member set and the prime member cast an approval.",
            "",
            " If the close operation completes successfully with disapproval, the transaction fee will",
            " be waived. Otherwise execution of the approved operation will be charged to the caller.",
            "",
            " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.",
            " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via",
            "                   `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(B + M + P1 + P2)` where:",
            "   - `B` is `proposal` size in bytes (length-fee-bounded)",
            "   - `M` is members-count (code- and governance-bounded)",
            "   - `P1` is the complexity of `proposal` preimage.",
            "   - `P2` is proposal-count (code-bounded)",
            " - DB:",
            "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)",
            "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)",
            "  - any mutations done while executing `proposal` (`P1`)",
            " - up to 3 events",
            " # </weight>"
          ]
        },
        {
          "Name": "disapprove_proposal",
          "Arguments": [
            {
              "Name": "proposal_hash",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Disapprove a proposal, close, and remove it from the system, regardless of its current state.",
            "",
            " Must be called by the Root origin.",
            "",
            " Parameters:",
            " * `proposal_hash`: The hash of the proposal that should be disapproved.",
            "",
            " # <weight>",
            " Complexity: O(P) where P is the number of max proposals",
            " DB Weight:",
            " * Reads: Proposals",
            " * Writes: Voting, Proposals, ProposalOf",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A motion (given hash) has been proposed (by given account) with a threshold (given",
            " `MemberCount`).",
            " \\[account, proposal_index, proposal_hash, threshold\\]"
          ],
          "Name": "Proposed",
          "EventArgs": [
            "AccountId",
            "ProposalIndex",
            "Hash",
            "MemberCount"
          ]
        },
        {
          "Documentations": [
            " A motion (given hash) has been voted on by given account, leaving",
            " a tally (yes votes and no votes given respectively as `MemberCount`).",
            " \\[account, proposal_hash, voted, yes, no\\]"
          ],
          "Name": "Voted",
          "EventArgs": [
            "AccountId",
            "Hash",
            "bool",
            "MemberCount",
            "MemberCount"
          ]
        },
        {
          "Documentations": [
            " A motion was approved by the required threshold.",
            " \\[proposal_hash\\]"
          ],
          "Name": "Approved",
          "EventArgs": [
            "Hash"
          ]
        },
        {
          "Documentations": [
            " A motion was not approved by the required threshold.",
            " \\[proposal_hash\\]"
          ],
          "Name": "Disapproved",
          "EventArgs": [
            "Hash"
          ]
        },
        {
          "Documentations": [
            " A motion was executed; result will be `Ok` if it returned without error.",
            " \\[proposal_hash, result\\]"
          ],
          "Name": "Executed",
          "EventArgs": [
            "Hash",
            "DispatchResult"
          ]
        },
        {
          "Documentations": [
            " A single member did some action; result will be `Ok` if it returned without error.",
            " \\[proposal_hash, result\\]"
          ],
          "Name": "MemberExecuted",
          "EventArgs": [
            "Hash",
            "DispatchResult"
          ]
        },
        {
          "Documentations": [
            " A proposal was closed because its threshold was reached or after its duration was up.",
            " \\[proposal_hash, yes, no\\]"
          ],
          "Name": "Closed",
          "EventArgs": [
            "Hash",
            "MemberCount",
            "MemberCount"
          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [
        {
          "Documentations": [
            " Account is not a member"
          ],
          "Name": "NotMember"
        },
        {
          "Documentations": [
            " Duplicate proposals not allowed"
          ],
          "Name": "DuplicateProposal"
        },
        {
          "Documentations": [
            " Proposal must exist"
          ],
          "Name": "ProposalMissing"
        },
        {
          "Documentations": [
            " Mismatched index"
          ],
          "Name": "WrongIndex"
        },
        {
          "Documentations": [
            " Duplicate vote ignored"
          ],
          "Name": "DuplicateVote"
        },
        {
          "Documentations": [
            " Members are already initialized!"
          ],
          "Name": "AlreadyInitialized"
        },
        {
          "Documentations": [
            " The close call was made too early, before the end of the voting."
          ],
          "Name": "TooEarly"
        },
        {
          "Documentations": [
            " There can only be a maximum of `MaxProposals` active proposals."
          ],
          "Name": "TooManyProposals"
        },
        {
          "Documentations": [
            " The given weight bound for the proposal was too low."
          ],
          "Name": "WrongProposalWeight"
        },
        {
          "Documentations": [
            " The given length bound for the proposal was too low."
          ],
          "Name": "WrongProposalLength"
        }
      ]
    },
    {
      "Name": "Elections",
      "Index": 19,
      "Storage": {
        "Prefix": "PhragmenElection",
        "Items": [
          {
            "Name": "Members",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<SeatHolder<T::AccountId, BalanceOf<T>>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current elected members.",
              "",
              " Invariant: Always sorted based on account id."
            ]
          },
          {
            "Name": "RunnersUp",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<SeatHolder<T::AccountId, BalanceOf<T>>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current reserved runners-up.",
              "",
              " Invariant: Always sorted based on rank (worse to best). Upon removal of a member, the",
              " last (i.e. _best_) runner-up will be replaced."
            ]
          },
          {
            "Name": "Candidates",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<(T::AccountId, BalanceOf<T>)>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The present candidate list. A current member or runner-up can never enter this vector",
              " and is always implicitly assumed to be a candidate.",
              "",
              " Second element is the deposit.",
              "",
              " Invariant: Always sorted based on account id."
            ]
          },
          {
            "Name": "ElectionRounds",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " The total number of vote rounds that have happened, excluding the upcoming one."
            ]
          },
          {
            "Name": "Voting",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "Voter<T::AccountId, BalanceOf<T>>",
              "IsLinked": false
            },
            "FallBack": "0x000000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " Votes and locked stake of a particular voter.",
              "",
              " TWOX-NOTE: SAFE as `AccountId` is a crypto hash."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "vote",
          "Arguments": [
            {
              "Name": "votes",
              "Type": "Vec<T::AccountId>"
            },
            {
              "Name": "value",
              "Type": "Compact<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Vote for a set of candidates for the upcoming round of election. This can be called to",
            " set the initial votes, or update already existing votes.",
            "",
            " Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is",
            " reserved. The deposit is based on the number of votes and can be updated over time.",
            "",
            " The `votes` should:",
            "   - not be empty.",
            "   - be less than the number of possible candidates. Note that all current members and",
            "     runners-up are also automatically candidates for the next round.",
            "",
            " If `value` is more than `who`'s total balance, then the maximum of the two is used.",
            "",
            " The dispatch origin of this call must be signed.",
            "",
            " ### Warning",
            "",
            " It is the responsibility of the caller to **NOT** place all of their balance into the",
            " lock and keep some for further operations.",
            "",
            " # <weight>",
            " We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less.",
            " # </weight>"
          ]
        },
        {
          "Name": "remove_voter",
          "Arguments": [

          ],
          "Documentations": [
            " Remove `origin` as a voter.",
            "",
            " This removes the lock and returns the deposit.",
            "",
            " The dispatch origin of this call must be signed and be a voter."
          ]
        },
        {
          "Name": "submit_candidacy",
          "Arguments": [
            {
              "Name": "candidate_count",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Submit oneself for candidacy. A fixed amount of deposit is recorded.",
            "",
            " All candidates are wiped at the end of the term. They either become a member/runner-up,",
            " or leave the system while their deposit is slashed.",
            "",
            " The dispatch origin of this call must be signed.",
            "",
            " ### Warning",
            "",
            " Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]",
            " to get their deposit back. Losing the spot in an election will always lead to a slash.",
            "",
            " # <weight>",
            " The number of current candidates must be provided as witness data.",
            " # </weight>"
          ]
        },
        {
          "Name": "renounce_candidacy",
          "Arguments": [
            {
              "Name": "renouncing",
              "Type": "Renouncing"
            }
          ],
          "Documentations": [
            " Renounce one's intention to be a candidate for the next election round. 3 potential",
            " outcomes exist:",
            "",
            " - `origin` is a candidate and not elected in any set. In this case, the deposit is",
            "   unreserved, returned and origin is removed as a candidate.",
            " - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and",
            "   origin is removed as a runner-up.",
            " - `origin` is a current member. In this case, the deposit is unreserved and origin is",
            "   removed as a member, consequently not being a candidate for the next round anymore.",
            "   Similar to [`remove_members`], if replacement runners exists, they are immediately used.",
            "   If the prime is renouncing, then no prime will exist until the next round.",
            "",
            " The dispatch origin of this call must be signed, and have one of the above roles.",
            "",
            " # <weight>",
            " The type of renouncing must be provided as witness data.",
            " # </weight>"
          ]
        },
        {
          "Name": "remove_member",
          "Arguments": [
            {
              "Name": "who",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "has_replacement",
              "Type": "bool"
            }
          ],
          "Documentations": [
            " Remove a particular member from the set. This is effective immediately and the bond of",
            " the outgoing member is slashed.",
            "",
            " If a runner-up is available, then the best runner-up will be removed and replaces the",
            " outgoing member. Otherwise, a new phragmen election is started.",
            "",
            " The dispatch origin of this call must be root.",
            "",
            " Note that this does not affect the designated block number of the next election.",
            "",
            " # <weight>",
            " If we have a replacement, we use a small weight. Else, since this is a root call and",
            " will go into phragmen, we assume full block for now.",
            " # </weight>"
          ]
        },
        {
          "Name": "clean_defunct_voters",
          "Arguments": [
            {
              "Name": "_num_voters",
              "Type": "u32"
            },
            {
              "Name": "_num_defunct",
              "Type": "u32"
            }
          ],
          "Documentations": [
            " Clean all voters who are defunct (i.e. they do not serve any purpose at all). The",
            " deposit of the removed voters are returned.",
            "",
            " This is an root function to be used only for cleaning the state.",
            "",
            " The dispatch origin of this call must be root.",
            "",
            " # <weight>",
            " The total number of voters and those that are defunct must be provided as witness data.",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A new term with \\[new_members\\]. This indicates that enough candidates existed to run the",
            " election, not that enough have has been elected. The inner value must be examined for",
            " this purpose. A `NewTerm(\\[\\])` indicates that some candidates got their bond slashed and",
            " none were elected, whilst `EmptyTerm` means that no candidates existed to begin with."
          ],
          "Name": "NewTerm",
          "EventArgs": [
            "Vec<(AccountId, Balance)>"
          ]
        },
        {
          "Documentations": [
            " No (or not enough) candidates existed for this round. This is different from",
            " `NewTerm(\\[\\])`. See the description of `NewTerm`."
          ],
          "Name": "EmptyTerm",
          "EventArgs": [

          ]
        },
        {
          "Documentations": [
            " Internal error happened while trying to perform election."
          ],
          "Name": "ElectionError",
          "EventArgs": [

          ]
        },
        {
          "Documentations": [
            " A \\[member\\] has been removed. This should always be followed by either `NewTerm` or",
            " `EmptyTerm`."
          ],
          "Name": "MemberKicked",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " Someone has renounced their candidacy."
          ],
          "Name": "Renounced",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A \\[candidate\\] was slashed by \\[amount\\] due to failing to obtain a seat as member or",
            " runner-up.",
            "",
            " Note that old members and runners-up are also candidates."
          ],
          "Name": "CandidateSlashed",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A \\[seat holder\\] was slashed by \\[amount\\] by being forcefully removed from the set."
          ],
          "Name": "SeatHolderSlashed",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "CandidacyBond",
          "Type": "BalanceOf<T>",
          "Value": "0x0080C6A47E8D03000000000000000000",
          "Documentations": [

          ]
        },
        {
          "Name": "VotingBondBase",
          "Type": "BalanceOf<T>",
          "Value": "0x00F0436DE36A01000000000000000000",
          "Documentations": [

          ]
        },
        {
          "Name": "VotingBondFactor",
          "Type": "BalanceOf<T>",
          "Value": "0x0000CC7B9FAE00000000000000000000",
          "Documentations": [

          ]
        },
        {
          "Name": "DesiredMembers",
          "Type": "u32",
          "Value": "0x0D000000",
          "Documentations": [

          ]
        },
        {
          "Name": "DesiredRunnersUp",
          "Type": "u32",
          "Value": "0x07000000",
          "Documentations": [

          ]
        },
        {
          "Name": "TermDuration",
          "Type": "T::BlockNumber",
          "Value": "0x80130300",
          "Documentations": [

          ]
        },
        {
          "Name": "ModuleId",
          "Type": "LockIdentifier",
          "Value": "0x706872656C656374",
          "Documentations": [

          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " Cannot vote when no candidates or members exist."
          ],
          "Name": "UnableToVote"
        },
        {
          "Documentations": [
            " Must vote for at least one candidate."
          ],
          "Name": "NoVotes"
        },
        {
          "Documentations": [
            " Cannot vote more than candidates."
          ],
          "Name": "TooManyVotes"
        },
        {
          "Documentations": [
            " Cannot vote more than maximum allowed."
          ],
          "Name": "MaximumVotesExceeded"
        },
        {
          "Documentations": [
            " Cannot vote with stake less than minimum balance."
          ],
          "Name": "LowBalance"
        },
        {
          "Documentations": [
            " Voter can not pay voting bond."
          ],
          "Name": "UnableToPayBond"
        },
        {
          "Documentations": [
            " Must be a voter."
          ],
          "Name": "MustBeVoter"
        },
        {
          "Documentations": [
            " Cannot report self."
          ],
          "Name": "ReportSelf"
        },
        {
          "Documentations": [
            " Duplicated candidate submission."
          ],
          "Name": "DuplicatedCandidate"
        },
        {
          "Documentations": [
            " Member cannot re-submit candidacy."
          ],
          "Name": "MemberSubmit"
        },
        {
          "Documentations": [
            " Runner cannot re-submit candidacy."
          ],
          "Name": "RunnerUpSubmit"
        },
        {
          "Documentations": [
            " Candidate does not have enough funds."
          ],
          "Name": "InsufficientCandidateFunds"
        },
        {
          "Documentations": [
            " Not a member."
          ],
          "Name": "NotMember"
        },
        {
          "Documentations": [
            " The provided count of number of candidates is incorrect."
          ],
          "Name": "InvalidWitnessData"
        },
        {
          "Documentations": [
            " The provided count of number of votes is incorrect."
          ],
          "Name": "InvalidVoteCount"
        },
        {
          "Documentations": [
            " The renouncing origin presented a wrong `Renouncing` parameter."
          ],
          "Name": "InvalidRenouncing"
        },
        {
          "Documentations": [
            " Prediction regarding replacement after member removal is wrong."
          ],
          "Name": "InvalidReplacement"
        }
      ]
    },
    {
      "Name": "TechnicalMembership",
      "Index": 20,
      "Storage": {
        "Prefix": "Instance1Membership",
        "Items": [
          {
            "Name": "Members",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current membership, stored as an ordered Vec."
            ]
          },
          {
            "Name": "Prime",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current prime member, if one exists."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "add_member",
          "Arguments": [
            {
              "Name": "who",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Add a member `who` to the set.",
            "",
            " May only be called from `T::AddOrigin`."
          ]
        },
        {
          "Name": "remove_member",
          "Arguments": [
            {
              "Name": "who",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Remove a member `who` from the set.",
            "",
            " May only be called from `T::RemoveOrigin`."
          ]
        },
        {
          "Name": "swap_member",
          "Arguments": [
            {
              "Name": "remove",
              "Type": "T::AccountId"
            },
            {
              "Name": "add",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Swap out one member `remove` for another `add`.",
            "",
            " May only be called from `T::SwapOrigin`.",
            "",
            " Prime membership is *not* passed from `remove` to `add`, if extant."
          ]
        },
        {
          "Name": "reset_members",
          "Arguments": [
            {
              "Name": "members",
              "Type": "Vec<T::AccountId>"
            }
          ],
          "Documentations": [
            " Change the membership to a new set, disregarding the existing membership. Be nice and",
            " pass `members` pre-sorted.",
            "",
            " May only be called from `T::ResetOrigin`."
          ]
        },
        {
          "Name": "change_key",
          "Arguments": [
            {
              "Name": "new",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Swap out the sending member for some other key `new`.",
            "",
            " May only be called from `Signed` origin of a current member.",
            "",
            " Prime membership is passed from the origin account to `new`, if extant."
          ]
        },
        {
          "Name": "set_prime",
          "Arguments": [
            {
              "Name": "who",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Set the prime member. Must be a current member.",
            "",
            " May only be called from `T::PrimeOrigin`."
          ]
        },
        {
          "Name": "clear_prime",
          "Arguments": [

          ],
          "Documentations": [
            " Remove the prime member if it exists.",
            "",
            " May only be called from `T::PrimeOrigin`."
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " The given member was added; see the transaction for who."
          ],
          "Name": "MemberAdded",
          "EventArgs": [

          ]
        },
        {
          "Documentations": [
            " The given member was removed; see the transaction for who."
          ],
          "Name": "MemberRemoved",
          "EventArgs": [

          ]
        },
        {
          "Documentations": [
            " Two members were swapped; see the transaction for who."
          ],
          "Name": "MembersSwapped",
          "EventArgs": [

          ]
        },
        {
          "Documentations": [
            " The membership was reset; see the transaction for who the new set is."
          ],
          "Name": "MembersReset",
          "EventArgs": [

          ]
        },
        {
          "Documentations": [
            " One of the members' keys changed."
          ],
          "Name": "KeyChanged",
          "EventArgs": [

          ]
        },
        {
          "Documentations": [
            " Phantom member, never used."
          ],
          "Name": "Dummy",
          "EventArgs": [
            "sp_std::marker::PhantomData<(AccountId, Event)>"
          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [

      ]
    },
    {
      "Name": "Treasury",
      "Index": 21,
      "Storage": {
        "Prefix": "Treasury",
        "Items": [
          {
            "Name": "ProposalCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "ProposalIndex",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " Number of proposals that have been made."
            ]
          },
          {
            "Name": "Proposals",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "ProposalIndex",
              "Key2": null,
              "Value": "Proposal<T::AccountId, BalanceOf<T, I>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Proposals that have been made."
            ]
          },
          {
            "Name": "Approvals",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<ProposalIndex>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Proposal indices that have been approved but not yet awarded."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "propose_spend",
          "Arguments": [
            {
              "Name": "value",
              "Type": "Compact<BalanceOf<T, I>>"
            },
            {
              "Name": "beneficiary",
              "Type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "Documentations": [
            " Put forward a suggestion for spending. A deposit proportional to the value",
            " is reserved and slashed if the proposal is rejected. It is returned once the",
            " proposal is awarded.",
            "",
            " # <weight>",
            " - Complexity: O(1)",
            " - DbReads: `ProposalCount`, `origin account`",
            " - DbWrites: `ProposalCount`, `Proposals`, `origin account`",
            " # </weight>"
          ]
        },
        {
          "Name": "reject_proposal",
          "Arguments": [
            {
              "Name": "proposal_id",
              "Type": "Compact<ProposalIndex>"
            }
          ],
          "Documentations": [
            " Reject a proposed spend. The original deposit will be slashed.",
            "",
            " May only be called from `T::RejectOrigin`.",
            "",
            " # <weight>",
            " - Complexity: O(1)",
            " - DbReads: `Proposals`, `rejected proposer account`",
            " - DbWrites: `Proposals`, `rejected proposer account`",
            " # </weight>"
          ]
        },
        {
          "Name": "approve_proposal",
          "Arguments": [
            {
              "Name": "proposal_id",
              "Type": "Compact<ProposalIndex>"
            }
          ],
          "Documentations": [
            " Approve a proposal. At a later time, the proposal will be allocated to the beneficiary",
            " and the original deposit will be returned.",
            "",
            " May only be called from `T::ApproveOrigin`.",
            "",
            " # <weight>",
            " - Complexity: O(1).",
            " - DbReads: `Proposals`, `Approvals`",
            " - DbWrite: `Approvals`",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " New proposal. \\[proposal_index\\]"
          ],
          "Name": "Proposed",
          "EventArgs": [
            "ProposalIndex"
          ]
        },
        {
          "Documentations": [
            " We have ended a spend period and will now allocate funds. \\[budget_remaining\\]"
          ],
          "Name": "Spending",
          "EventArgs": [
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Some funds have been allocated. \\[proposal_index, award, beneficiary\\]"
          ],
          "Name": "Awarded",
          "EventArgs": [
            "ProposalIndex",
            "Balance",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A proposal was rejected; funds were slashed. \\[proposal_index, slashed\\]"
          ],
          "Name": "Rejected",
          "EventArgs": [
            "ProposalIndex",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Some of our funds have been burnt. \\[burn\\]"
          ],
          "Name": "Burnt",
          "EventArgs": [
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Spending has finished; this is the amount that rolls over until next spend.",
            " \\[budget_remaining\\]"
          ],
          "Name": "Rollover",
          "EventArgs": [
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Some funds have been deposited. \\[deposit\\]"
          ],
          "Name": "Deposit",
          "EventArgs": [
            "Balance"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "ProposalBond",
          "Type": "Permill",
          "Value": "0x50C30000",
          "Documentations": [
            " Fraction of a proposal's value that should be bonded in order to place the proposal.",
            " An accepted proposal gets these back. A rejected proposal does not."
          ]
        },
        {
          "Name": "ProposalBondMinimum",
          "Type": "BalanceOf<T, I>",
          "Value": "0x00407A10F35A00000000000000000000",
          "Documentations": [
            " Minimum amount of funds that should be placed in a deposit for making a proposal."
          ]
        },
        {
          "Name": "SpendPeriod",
          "Type": "T::BlockNumber",
          "Value": "0x80700000",
          "Documentations": [
            " Period between successive spends."
          ]
        },
        {
          "Name": "Burn",
          "Type": "Permill",
          "Value": "0x20A10700",
          "Documentations": [
            " Percentage of spare funds (if any) that are burnt per spend period."
          ]
        },
        {
          "Name": "ModuleId",
          "Type": "ModuleId",
          "Value": "0x70792F7472737279",
          "Documentations": [
            " The treasury's module id, used for deriving its sovereign account ID."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " Proposer's balance is too low."
          ],
          "Name": "InsufficientProposersBalance"
        },
        {
          "Documentations": [
            " No proposal or bounty at that index."
          ],
          "Name": "InvalidIndex"
        }
      ]
    },
    {
      "Name": "Vesting",
      "Index": 22,
      "Storage": {
        "Prefix": "Vesting",
        "Items": [
          {
            "Name": "Vesting",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "VestingInfo<BalanceOf<T>, T::BlockNumber>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Information regarding the vesting of a given account."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "vest",
          "Arguments": [

          ],
          "Documentations": [
            " Unlock any vested funds of the sender account.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have funds still",
            " locked under this module.",
            "",
            " Emits either `VestingCompleted` or `VestingUpdated`.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - DbWeight: 2 Reads, 2 Writes",
            "     - Reads: Vesting Storage, Balances Locks, [Sender Account]",
            "     - Writes: Vesting Storage, Balances Locks, [Sender Account]",
            " # </weight>"
          ]
        },
        {
          "Name": "vest_other",
          "Arguments": [
            {
              "Name": "target",
              "Type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "Documentations": [
            " Unlock any vested funds of a `target` account.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `target`: The account whose vested funds should be unlocked. Must have funds still",
            " locked under this module.",
            "",
            " Emits either `VestingCompleted` or `VestingUpdated`.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - DbWeight: 3 Reads, 3 Writes",
            "     - Reads: Vesting Storage, Balances Locks, Target Account",
            "     - Writes: Vesting Storage, Balances Locks, Target Account",
            " # </weight>"
          ]
        },
        {
          "Name": "vested_transfer",
          "Arguments": [
            {
              "Name": "target",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "schedule",
              "Type": "VestingInfo<BalanceOf<T>, T::BlockNumber>"
            }
          ],
          "Documentations": [
            " Create a vested transfer.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `target`: The account that should be transferred the vested funds.",
            " - `amount`: The amount of funds to transfer and will be vested.",
            " - `schedule`: The vesting schedule attached to the transfer.",
            "",
            " Emits `VestingCreated`.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - DbWeight: 3 Reads, 3 Writes",
            "     - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]",
            "     - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]",
            " # </weight>"
          ]
        },
        {
          "Name": "force_vested_transfer",
          "Arguments": [
            {
              "Name": "source",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "target",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "schedule",
              "Type": "VestingInfo<BalanceOf<T>, T::BlockNumber>"
            }
          ],
          "Documentations": [
            " Force a vested transfer.",
            "",
            " The dispatch origin for this call must be _Root_.",
            "",
            " - `source`: The account whose funds should be transferred.",
            " - `target`: The account that should be transferred the vested funds.",
            " - `amount`: The amount of funds to transfer and will be vested.",
            " - `schedule`: The vesting schedule attached to the transfer.",
            "",
            " Emits `VestingCreated`.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - DbWeight: 4 Reads, 4 Writes",
            "     - Reads: Vesting Storage, Balances Locks, Target Account, Source Account",
            "     - Writes: Vesting Storage, Balances Locks, Target Account, Source Account",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " The amount vested has been updated. This could indicate more funds are available. The",
            " balance given is the amount which is left unvested (and thus locked).",
            " \\[account, unvested\\]"
          ],
          "Name": "VestingUpdated",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " An \\[account\\] has become fully vested. No further vesting can happen."
          ],
          "Name": "VestingCompleted",
          "EventArgs": [
            "AccountId"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "MinVestedTransfer",
          "Type": "BalanceOf<T>",
          "Value": "0x0000C16FF28623000000000000000000",
          "Documentations": [
            " The minimum amount to be transferred to create a new vesting schedule."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " The account given is not vesting."
          ],
          "Name": "NotVesting"
        },
        {
          "Documentations": [
            " An existing vesting schedule already exists for this account that cannot be clobbered."
          ],
          "Name": "ExistingVestingSchedule"
        },
        {
          "Documentations": [
            " Amount being transferred is too low to create a vesting schedule."
          ],
          "Name": "AmountLow"
        }
      ]
    },
    {
      "Name": "Utility",
      "Index": 23,
      "Storage": null,
      "Calls": [
        {
          "Name": "batch",
          "Arguments": [
            {
              "Name": "calls",
              "Type": "Vec<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Send a batch of dispatch calls.",
            "",
            " May be called from any origin.",
            "",
            " - `calls`: The calls to be dispatched from the same origin.",
            "",
            " If origin is root then call are dispatch without checking origin filter. (This includes",
            " bypassing `frame_system::Config::BaseCallFilter`).",
            "",
            " # <weight>",
            " - Complexity: O(C) where C is the number of calls to be batched.",
            " # </weight>",
            "",
            " This will return `Ok` in all circumstances. To determine the success of the batch, an",
            " event is deposited. If a call failed and the batch was interrupted, then the",
            " `BatchInterrupted` event is deposited, along with the number of successful calls made",
            " and the error of the failed call. If all were successful, then the `BatchCompleted`",
            " event is deposited."
          ]
        },
        {
          "Name": "as_derivative",
          "Arguments": [
            {
              "Name": "index",
              "Type": "u16"
            },
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Send a call through an indexed pseudonym of the sender.",
            "",
            " Filter from origin are passed along. The call will be dispatched with an origin which",
            " use the same filter as the origin of this call.",
            "",
            " NOTE: If you need to ensure that any account-based filtering is not honored (i.e.",
            " because you expect `proxy` to have been used prior in the call stack and you do not want",
            " the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`",
            " in the Multisig pallet instead.",
            "",
            " NOTE: Prior to version *12, this was called `as_limited_sub`.",
            "",
            " The dispatch origin for this call must be _Signed_."
          ]
        },
        {
          "Name": "batch_all",
          "Arguments": [
            {
              "Name": "calls",
              "Type": "Vec<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Send a batch of dispatch calls and atomically execute them.",
            " The whole transaction will rollback and fail if any of the calls failed.",
            "",
            " May be called from any origin.",
            "",
            " - `calls`: The calls to be dispatched from the same origin.",
            "",
            " If origin is root then call are dispatch without checking origin filter. (This includes",
            " bypassing `frame_system::Config::BaseCallFilter`).",
            "",
            " # <weight>",
            " - Complexity: O(C) where C is the number of calls to be batched.",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " Batch of dispatches did not complete fully. Index of first failing dispatch given, as",
            " well as the error. \\[index, error\\]"
          ],
          "Name": "BatchInterrupted",
          "EventArgs": [
            "u32",
            "DispatchError"
          ]
        },
        {
          "Documentations": [
            " Batch of dispatches completed fully with no error."
          ],
          "Name": "BatchCompleted",
          "EventArgs": [

          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [

      ]
    },
    {
      "Name": "Identity",
      "Index": 24,
      "Storage": {
        "Prefix": "Identity",
        "Items": [
          {
            "Name": "IdentityOf",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "Registration<BalanceOf<T>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Information that is pertinent to identify the entity behind an account.",
              "",
              " TWOX-NOTE: OK â?? `AccountId` is a secure hash."
            ]
          },
          {
            "Name": "SuperOf",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "(T::AccountId, Data)",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The super-identity of an alternative \"sub\" identity together with its name, within that",
              " context. If the account is not some other account's sub-identity, then just `None`."
            ]
          },
          {
            "Name": "SubsOf",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "(BalanceOf<T>, Vec<T::AccountId>)",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000",
            "Documentations": [
              " Alternative \"sub\" identities of this account.",
              "",
              " The first item is the deposit, the second is a vector of the accounts.",
              "",
              " TWOX-NOTE: OK â?? `AccountId` is a secure hash."
            ]
          },
          {
            "Name": "Registrars",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<Option<RegistrarInfo<BalanceOf<T>, T::AccountId>>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The set of registrars. Not expected to get very big as can only be added through a",
              " special origin (likely a council motion).",
              "",
              " The index into this can be cast to `RegistrarIndex` to get a valid value."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "add_registrar",
          "Arguments": [
            {
              "Name": "account",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Add a registrar to the system.",
            "",
            " The dispatch origin for this call must be `T::RegistrarOrigin`.",
            "",
            " - `account`: the account of the registrar.",
            "",
            " Emits `RegistrarAdded` if successful.",
            "",
            " # <weight>",
            " - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).",
            " - One storage mutation (codec `O(R)`).",
            " - One event.",
            " # </weight>"
          ]
        },
        {
          "Name": "set_identity",
          "Arguments": [
            {
              "Name": "info",
              "Type": "IdentityInfo"
            }
          ],
          "Documentations": [
            " Set an account's identity information and reserve the appropriate deposit.",
            "",
            " If the account already has identity information, the deposit is taken as part payment",
            " for the new deposit.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `info`: The identity information.",
            "",
            " Emits `IdentitySet` if successful.",
            "",
            " # <weight>",
            " - `O(X + X' + R)`",
            "   - where `X` additional-field-count (deposit-bounded and code-bounded)",
            "   - where `R` judgements-count (registrar-count-bounded)",
            " - One balance reserve operation.",
            " - One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).",
            " - One event.",
            " # </weight>"
          ]
        },
        {
          "Name": "set_subs",
          "Arguments": [
            {
              "Name": "subs",
              "Type": "Vec<(T::AccountId, Data)>"
            }
          ],
          "Documentations": [
            " Set the sub-accounts of the sender.",
            "",
            " Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned",
            " and an amount `SubAccountDeposit` will be reserved for each item in `subs`.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " identity.",
            "",
            " - `subs`: The identity's (new) sub-accounts.",
            "",
            " # <weight>",
            " - `O(P + S)`",
            "   - where `P` old-subs-count (hard- and deposit-bounded).",
            "   - where `S` subs-count (hard- and deposit-bounded).",
            " - At most one balance operations.",
            " - DB:",
            "   - `P + S` storage mutations (codec complexity `O(1)`)",
            "   - One storage read (codec complexity `O(P)`).",
            "   - One storage write (codec complexity `O(S)`).",
            "   - One storage-exists (`IdentityOf::contains_key`).",
            " # </weight>"
          ]
        },
        {
          "Name": "clear_identity",
          "Arguments": [

          ],
          "Documentations": [
            " Clear an account's identity info and all sub-accounts and return all deposits.",
            "",
            " Payment: All reserved balances on the account are returned.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " identity.",
            "",
            " Emits `IdentityCleared` if successful.",
            "",
            " # <weight>",
            " - `O(R + S + X)`",
            "   - where `R` registrar-count (governance-bounded).",
            "   - where `S` subs-count (hard- and deposit-bounded).",
            "   - where `X` additional-field-count (deposit-bounded and code-bounded).",
            " - One balance-unreserve operation.",
            " - `2` storage reads and `S + 2` storage deletions.",
            " - One event.",
            " # </weight>"
          ]
        },
        {
          "Name": "request_judgement",
          "Arguments": [
            {
              "Name": "reg_index",
              "Type": "Compact<RegistrarIndex>"
            },
            {
              "Name": "max_fee",
              "Type": "Compact<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Request a judgement from a registrar.",
            "",
            " Payment: At most `max_fee` will be reserved for payment to the registrar if judgement",
            " given.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a",
            " registered identity.",
            "",
            " - `reg_index`: The index of the registrar whose judgement is requested.",
            " - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:",
            "",
            " ```nocompile",
            " Self::registrars().get(reg_index).unwrap().fee",
            " ```",
            "",
            " Emits `JudgementRequested` if successful.",
            "",
            " # <weight>",
            " - `O(R + X)`.",
            " - One balance-reserve operation.",
            " - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.",
            " - One event.",
            " # </weight>"
          ]
        },
        {
          "Name": "cancel_request",
          "Arguments": [
            {
              "Name": "reg_index",
              "Type": "RegistrarIndex"
            }
          ],
          "Documentations": [
            " Cancel a previous request.",
            "",
            " Payment: A previously reserved deposit is returned on success.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a",
            " registered identity.",
            "",
            " - `reg_index`: The index of the registrar whose judgement is no longer requested.",
            "",
            " Emits `JudgementUnrequested` if successful.",
            "",
            " # <weight>",
            " - `O(R + X)`.",
            " - One balance-reserve operation.",
            " - One storage mutation `O(R + X)`.",
            " - One event",
            " # </weight>"
          ]
        },
        {
          "Name": "set_fee",
          "Arguments": [
            {
              "Name": "index",
              "Type": "Compact<RegistrarIndex>"
            },
            {
              "Name": "fee",
              "Type": "Compact<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Set the fee required for a judgement to be requested from a registrar.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must be the account",
            " of the registrar whose index is `index`.",
            "",
            " - `index`: the index of the registrar whose fee is to be set.",
            " - `fee`: the new fee.",
            "",
            " # <weight>",
            " - `O(R)`.",
            " - One storage mutation `O(R)`.",
            " - Benchmark: 7.315 + R * 0.329 Âµs (min squares analysis)",
            " # </weight>"
          ]
        },
        {
          "Name": "set_account_id",
          "Arguments": [
            {
              "Name": "index",
              "Type": "Compact<RegistrarIndex>"
            },
            {
              "Name": "new",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Change the account associated with a registrar.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must be the account",
            " of the registrar whose index is `index`.",
            "",
            " - `index`: the index of the registrar whose fee is to be set.",
            " - `new`: the new account ID.",
            "",
            " # <weight>",
            " - `O(R)`.",
            " - One storage mutation `O(R)`.",
            " - Benchmark: 8.823 + R * 0.32 Âµs (min squares analysis)",
            " # </weight>"
          ]
        },
        {
          "Name": "set_fields",
          "Arguments": [
            {
              "Name": "index",
              "Type": "Compact<RegistrarIndex>"
            },
            {
              "Name": "fields",
              "Type": "IdentityFields"
            }
          ],
          "Documentations": [
            " Set the field information for a registrar.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must be the account",
            " of the registrar whose index is `index`.",
            "",
            " - `index`: the index of the registrar whose fee is to be set.",
            " - `fields`: the fields that the registrar concerns themselves with.",
            "",
            " # <weight>",
            " - `O(R)`.",
            " - One storage mutation `O(R)`.",
            " - Benchmark: 7.464 + R * 0.325 Âµs (min squares analysis)",
            " # </weight>"
          ]
        },
        {
          "Name": "provide_judgement",
          "Arguments": [
            {
              "Name": "reg_index",
              "Type": "Compact<RegistrarIndex>"
            },
            {
              "Name": "target",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "judgement",
              "Type": "Judgement<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Provide a judgement for an account's identity.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must be the account",
            " of the registrar whose index is `reg_index`.",
            "",
            " - `reg_index`: the index of the registrar whose judgement is being made.",
            " - `target`: the account whose identity the judgement is upon. This must be an account",
            "   with a registered identity.",
            " - `judgement`: the judgement of the registrar of index `reg_index` about `target`.",
            "",
            " Emits `JudgementGiven` if successful.",
            "",
            " # <weight>",
            " - `O(R + X)`.",
            " - One balance-transfer operation.",
            " - Up to one account-lookup operation.",
            " - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.",
            " - One event.",
            " # </weight>"
          ]
        },
        {
          "Name": "kill_identity",
          "Arguments": [
            {
              "Name": "target",
              "Type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "Documentations": [
            " Remove an account's identity and sub-account information and slash the deposits.",
            "",
            " Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by",
            " `Slash`. Verification request deposits are not returned; they should be cancelled",
            " manually using `cancel_request`.",
            "",
            " The dispatch origin for this call must match `T::ForceOrigin`.",
            "",
            " - `target`: the account whose identity the judgement is upon. This must be an account",
            "   with a registered identity.",
            "",
            " Emits `IdentityKilled` if successful.",
            "",
            " # <weight>",
            " - `O(R + S + X)`.",
            " - One balance-reserve operation.",
            " - `S + 2` storage mutations.",
            " - One event.",
            " # </weight>"
          ]
        },
        {
          "Name": "add_sub",
          "Arguments": [
            {
              "Name": "sub",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "data",
              "Type": "Data"
            }
          ],
          "Documentations": [
            " Add the given account to the sender's subs.",
            "",
            " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
            " to the sender.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " sub identity of `sub`."
          ]
        },
        {
          "Name": "rename_sub",
          "Arguments": [
            {
              "Name": "sub",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "data",
              "Type": "Data"
            }
          ],
          "Documentations": [
            " Alter the associated name of the given sub-account.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " sub identity of `sub`."
          ]
        },
        {
          "Name": "remove_sub",
          "Arguments": [
            {
              "Name": "sub",
              "Type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "Documentations": [
            " Remove the given account from the sender's subs.",
            "",
            " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
            " to the sender.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " sub identity of `sub`."
          ]
        },
        {
          "Name": "quit_sub",
          "Arguments": [

          ],
          "Documentations": [
            " Remove the sender as a sub-account.",
            "",
            " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
            " to the sender (*not* the original depositor).",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " super-identity.",
            "",
            " NOTE: This should not normally be used, but is provided in the case that the non-",
            " controller of an account is maliciously registered as a sub-account."
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A name was set or reset (which will remove all judgements). \\[who\\]"
          ],
          "Name": "IdentitySet",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A name was cleared, and the given balance returned. \\[who, deposit\\]"
          ],
          "Name": "IdentityCleared",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A name was removed and the given balance slashed. \\[who, deposit\\]"
          ],
          "Name": "IdentityKilled",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A judgement was asked from a registrar. \\[who, registrar_index\\]"
          ],
          "Name": "JudgementRequested",
          "EventArgs": [
            "AccountId",
            "RegistrarIndex"
          ]
        },
        {
          "Documentations": [
            " A judgement request was retracted. \\[who, registrar_index\\]"
          ],
          "Name": "JudgementUnrequested",
          "EventArgs": [
            "AccountId",
            "RegistrarIndex"
          ]
        },
        {
          "Documentations": [
            " A judgement was given by a registrar. \\[target, registrar_index\\]"
          ],
          "Name": "JudgementGiven",
          "EventArgs": [
            "AccountId",
            "RegistrarIndex"
          ]
        },
        {
          "Documentations": [
            " A registrar was added. \\[registrar_index\\]"
          ],
          "Name": "RegistrarAdded",
          "EventArgs": [
            "RegistrarIndex"
          ]
        },
        {
          "Documentations": [
            " A sub-identity was added to an identity and the deposit paid. \\[sub, main, deposit\\]"
          ],
          "Name": "SubIdentityAdded",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A sub-identity was removed from an identity and the deposit freed.",
            " \\[sub, main, deposit\\]"
          ],
          "Name": "SubIdentityRemoved",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A sub-identity was cleared, and the given deposit repatriated from the",
            " main identity account to the sub-identity account. \\[sub, main, deposit\\]"
          ],
          "Name": "SubIdentityRevoked",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "Balance"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "BasicDeposit",
          "Type": "BalanceOf<T>",
          "Value": "0x0080C6A47E8D03000000000000000000",
          "Documentations": [
            " The amount held on deposit for a registered identity."
          ]
        },
        {
          "Name": "FieldDeposit",
          "Type": "BalanceOf<T>",
          "Value": "0x00A031A95FE300000000000000000000",
          "Documentations": [
            " The amount held on deposit per additional field for a registered identity."
          ]
        },
        {
          "Name": "SubAccountDeposit",
          "Type": "BalanceOf<T>",
          "Value": "0x0080F420E6B500000000000000000000",
          "Documentations": [
            " The amount held on deposit for a registered subaccount. This should account for the fact",
            " that one storage item's value will increase by the size of an account ID, and there will be",
            " another trie item whose value is the size of an account ID plus 32 bytes."
          ]
        },
        {
          "Name": "MaxSubAccounts",
          "Type": "u32",
          "Value": "0x64000000",
          "Documentations": [
            " The maximum number of sub-accounts allowed per identified account."
          ]
        },
        {
          "Name": "MaxAdditionalFields",
          "Type": "u32",
          "Value": "0x64000000",
          "Documentations": [
            " Maximum number of additional fields that may be stored in an ID. Needed to bound the I/O",
            " required to access an identity, but can be pretty high."
          ]
        },
        {
          "Name": "MaxRegistrars",
          "Type": "u32",
          "Value": "0x14000000",
          "Documentations": [
            " Maxmimum number of registrars allowed in the system. Needed to bound the complexity",
            " of, e.g., updating judgements."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " Too many subs-accounts."
          ],
          "Name": "TooManySubAccounts"
        },
        {
          "Documentations": [
            " Account isn't found."
          ],
          "Name": "NotFound"
        },
        {
          "Documentations": [
            " Account isn't named."
          ],
          "Name": "NotNamed"
        },
        {
          "Documentations": [
            " Empty index."
          ],
          "Name": "EmptyIndex"
        },
        {
          "Documentations": [
            " Fee is changed."
          ],
          "Name": "FeeChanged"
        },
        {
          "Documentations": [
            " No identity found."
          ],
          "Name": "NoIdentity"
        },
        {
          "Documentations": [
            " Sticky judgement."
          ],
          "Name": "StickyJudgement"
        },
        {
          "Documentations": [
            " Judgement given."
          ],
          "Name": "JudgementGiven"
        },
        {
          "Documentations": [
            " Invalid judgement."
          ],
          "Name": "InvalidJudgement"
        },
        {
          "Documentations": [
            " The index is invalid."
          ],
          "Name": "InvalidIndex"
        },
        {
          "Documentations": [
            " The target is invalid."
          ],
          "Name": "InvalidTarget"
        },
        {
          "Documentations": [
            " Too many additional fields."
          ],
          "Name": "TooManyFields"
        },
        {
          "Documentations": [
            " Maximum amount of registrars reached. Cannot add any more."
          ],
          "Name": "TooManyRegistrars"
        },
        {
          "Documentations": [
            " Account ID is already named."
          ],
          "Name": "AlreadyClaimed"
        },
        {
          "Documentations": [
            " Sender is not a sub-account."
          ],
          "Name": "NotSub"
        },
        {
          "Documentations": [
            " Sub-account isn't owned by sender."
          ],
          "Name": "NotOwned"
        }
      ]
    },
    {
      "Name": "Proxy",
      "Index": 25,
      "Storage": {
        "Prefix": "Proxy",
        "Items": [
          {
            "Name": "Proxies",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "(Vec<ProxyDefinition<T::AccountId, T::ProxyType, T::BlockNumber>>,\n BalanceOf<T>)",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000",
            "Documentations": [
              " The set of account proxies. Maps the account which has delegated to the accounts",
              " which are being delegated to, together with the amount held on deposit."
            ]
          },
          {
            "Name": "Announcements",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "(Vec<Announcement<T::AccountId, CallHashOf<T>, T::BlockNumber>>,\n BalanceOf<T>)",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000",
            "Documentations": [
              " The announcements made by the proxy (key)."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "proxy",
          "Arguments": [
            {
              "Name": "real",
              "Type": "T::AccountId"
            },
            {
              "Name": "force_proxy_type",
              "Type": "Option<T::ProxyType>"
            },
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Dispatch the given `call` from an account that the sender is authorised for through",
            " `add_proxy`.",
            "",
            " Removes any corresponding announcement(s).",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `real`: The account that the proxy will make a call on behalf of.",
            " - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.",
            " - `call`: The call to be made by the `real` account.",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # </weight>"
          ]
        },
        {
          "Name": "add_proxy",
          "Arguments": [
            {
              "Name": "delegate",
              "Type": "T::AccountId"
            },
            {
              "Name": "proxy_type",
              "Type": "T::ProxyType"
            },
            {
              "Name": "delay",
              "Type": "T::BlockNumber"
            }
          ],
          "Documentations": [
            " Register a proxy account for the sender that is able to make calls on its behalf.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `proxy`: The account that the `caller` would like to make a proxy.",
            " - `proxy_type`: The permissions allowed for this proxy account.",
            " - `delay`: The announcement period required of the initial proxy. Will generally be",
            " zero.",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # </weight>"
          ]
        },
        {
          "Name": "remove_proxy",
          "Arguments": [
            {
              "Name": "delegate",
              "Type": "T::AccountId"
            },
            {
              "Name": "proxy_type",
              "Type": "T::ProxyType"
            },
            {
              "Name": "delay",
              "Type": "T::BlockNumber"
            }
          ],
          "Documentations": [
            " Unregister a proxy account for the sender.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `proxy`: The account that the `caller` would like to remove as a proxy.",
            " - `proxy_type`: The permissions currently enabled for the removed proxy account.",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # </weight>"
          ]
        },
        {
          "Name": "remove_proxies",
          "Arguments": [

          ],
          "Documentations": [
            " Unregister all proxy accounts for the sender.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " WARNING: This may be called on accounts created by `anonymous`, however if done, then",
            " the unreserved fees will be inaccessible. **All access to this account will be lost.**",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # </weight>"
          ]
        },
        {
          "Name": "anonymous",
          "Arguments": [
            {
              "Name": "proxy_type",
              "Type": "T::ProxyType"
            },
            {
              "Name": "delay",
              "Type": "T::BlockNumber"
            },
            {
              "Name": "index",
              "Type": "u16"
            }
          ],
          "Documentations": [
            " Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and",
            " initialize it with a proxy of `proxy_type` for `origin` sender.",
            "",
            " Requires a `Signed` origin.",
            "",
            " - `proxy_type`: The type of the proxy that the sender will be registered as over the",
            " new account. This will almost always be the most permissive `ProxyType` possible to",
            " allow for maximum flexibility.",
            " - `index`: A disambiguation index, in case this is called multiple times in the same",
            " transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just",
            " want to use `0`.",
            " - `delay`: The announcement period required of the initial proxy. Will generally be",
            " zero.",
            "",
            " Fails with `Duplicate` if this has already been called in this transaction, from the",
            " same sender, with the same parameters.",
            "",
            " Fails if there are insufficient funds to pay for deposit.",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # </weight>",
            " TODO: Might be over counting 1 read"
          ]
        },
        {
          "Name": "kill_anonymous",
          "Arguments": [
            {
              "Name": "spawner",
              "Type": "T::AccountId"
            },
            {
              "Name": "proxy_type",
              "Type": "T::ProxyType"
            },
            {
              "Name": "index",
              "Type": "u16"
            },
            {
              "Name": "height",
              "Type": "Compact<T::BlockNumber>"
            },
            {
              "Name": "ext_index",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Removes a previously spawned anonymous proxy.",
            "",
            " WARNING: **All access to this account will be lost.** Any funds held in it will be",
            " inaccessible.",
            "",
            " Requires a `Signed` origin, and the sender account must have been created by a call to",
            " `anonymous` with corresponding parameters.",
            "",
            " - `spawner`: The account that originally called `anonymous` to create this account.",
            " - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.",
            " - `proxy_type`: The proxy type originally passed to `anonymous`.",
            " - `height`: The height of the chain when the call to `anonymous` was processed.",
            " - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.",
            "",
            " Fails with `NoPermission` in case the caller is not a previously created anonymous",
            " account whose `anonymous` call has corresponding parameters.",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # </weight>"
          ]
        },
        {
          "Name": "announce",
          "Arguments": [
            {
              "Name": "real",
              "Type": "T::AccountId"
            },
            {
              "Name": "call_hash",
              "Type": "CallHashOf<T>"
            }
          ],
          "Documentations": [
            " Publish the hash of a proxy-call that will be made in the future.",
            "",
            " This must be called some number of blocks before the corresponding `proxy` is attempted",
            " if the delay associated with the proxy relationship is greater than zero.",
            "",
            " No more than `MaxPending` announcements may be made at any one time.",
            "",
            " This will take a deposit of `AnnouncementDepositFactor` as well as",
            " `AnnouncementDepositBase` if there are no other pending announcements.",
            "",
            " The dispatch origin for this call must be _Signed_ and a proxy of `real`.",
            "",
            " Parameters:",
            " - `real`: The account that the proxy will make a call on behalf of.",
            " - `call_hash`: The hash of the call to be made by the `real` account.",
            "",
            " # <weight>",
            " Weight is a function of:",
            " - A: the number of announcements made.",
            " - P: the number of proxies the user has.",
            " # </weight>"
          ]
        },
        {
          "Name": "remove_announcement",
          "Arguments": [
            {
              "Name": "real",
              "Type": "T::AccountId"
            },
            {
              "Name": "call_hash",
              "Type": "CallHashOf<T>"
            }
          ],
          "Documentations": [
            " Remove a given announcement.",
            "",
            " May be called by a proxy account to remove a call they previously announced and return",
            " the deposit.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `real`: The account that the proxy will make a call on behalf of.",
            " - `call_hash`: The hash of the call to be made by the `real` account.",
            "",
            " # <weight>",
            " Weight is a function of:",
            " - A: the number of announcements made.",
            " - P: the number of proxies the user has.",
            " # </weight>"
          ]
        },
        {
          "Name": "reject_announcement",
          "Arguments": [
            {
              "Name": "delegate",
              "Type": "T::AccountId"
            },
            {
              "Name": "call_hash",
              "Type": "CallHashOf<T>"
            }
          ],
          "Documentations": [
            " Remove the given announcement of a delegate.",
            "",
            " May be called by a target (proxied) account to remove a call that one of their delegates",
            " (`delegate`) has announced they want to execute. The deposit is returned.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `delegate`: The account that previously announced the call.",
            " - `call_hash`: The hash of the call to be made.",
            "",
            " # <weight>",
            " Weight is a function of:",
            " - A: the number of announcements made.",
            " - P: the number of proxies the user has.",
            " # </weight>"
          ]
        },
        {
          "Name": "proxy_announced",
          "Arguments": [
            {
              "Name": "delegate",
              "Type": "T::AccountId"
            },
            {
              "Name": "real",
              "Type": "T::AccountId"
            },
            {
              "Name": "force_proxy_type",
              "Type": "Option<T::ProxyType>"
            },
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Dispatch the given `call` from an account that the sender is authorised for through",
            " `add_proxy`.",
            "",
            " Removes any corresponding announcement(s).",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `real`: The account that the proxy will make a call on behalf of.",
            " - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.",
            " - `call`: The call to be made by the `real` account.",
            "",
            " # <weight>",
            " Weight is a function of:",
            " - A: the number of announcements made.",
            " - P: the number of proxies the user has.",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A proxy was executed correctly, with the given \\[result\\]."
          ],
          "Name": "ProxyExecuted",
          "EventArgs": [
            "DispatchResult"
          ]
        },
        {
          "Documentations": [
            " Anonymous account has been created by new proxy with given",
            " disambiguation index and proxy type. \\[anonymous, who, proxy_type, disambiguation_index\\]"
          ],
          "Name": "AnonymousCreated",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "ProxyType",
            "u16"
          ]
        },
        {
          "Documentations": [
            " An announcement was placed to make a call in the future. \\[real, proxy, call_hash\\]"
          ],
          "Name": "Announced",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "Hash"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "ProxyDepositBase",
          "Type": "BalanceOf<T>",
          "Value": "0x00F09E544C3900000000000000000000",
          "Documentations": [
            " The base amount of currency needed to reserve for creating a proxy."
          ]
        },
        {
          "Name": "ProxyDepositFactor",
          "Type": "BalanceOf<T>",
          "Value": "0x0060AA7714B400000000000000000000",
          "Documentations": [
            " The amount of currency needed per proxy added."
          ]
        },
        {
          "Name": "MaxProxies",
          "Type": "u16",
          "Value": "0x2000",
          "Documentations": [
            " The maximum amount of proxies allowed for a single account."
          ]
        },
        {
          "Name": "MaxPending",
          "Type": "u32",
          "Value": "0x20000000",
          "Documentations": [
            " `MaxPending` metadata shadow."
          ]
        },
        {
          "Name": "AnnouncementDepositBase",
          "Type": "BalanceOf<T>",
          "Value": "0x00F09E544C3900000000000000000000",
          "Documentations": [
            " `AnnouncementDepositBase` metadata shadow."
          ]
        },
        {
          "Name": "AnnouncementDepositFactor",
          "Type": "BalanceOf<T>",
          "Value": "0x00C054EF286801000000000000000000",
          "Documentations": [
            " `AnnouncementDepositFactor` metadata shadow."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " There are too many proxies registered or too many announcements pending."
          ],
          "Name": "TooMany"
        },
        {
          "Documentations": [
            " Proxy registration not found."
          ],
          "Name": "NotFound"
        },
        {
          "Documentations": [
            " Sender is not a proxy of the account to be proxied."
          ],
          "Name": "NotProxy"
        },
        {
          "Documentations": [
            " A call which is incompatible with the proxy type's filter was attempted."
          ],
          "Name": "Unproxyable"
        },
        {
          "Documentations": [
            " Account is already a proxy."
          ],
          "Name": "Duplicate"
        },
        {
          "Documentations": [
            " Call may not be made by proxy because it may escalate its privileges."
          ],
          "Name": "NoPermission"
        },
        {
          "Documentations": [
            " Announcement, if made at all, was made too recently."
          ],
          "Name": "Unannounced"
        },
        {
          "Documentations": [
            " Cannot add self as proxy."
          ],
          "Name": "NoSelfProxy"
        }
      ]
    },
    {
      "Name": "Multisig",
      "Index": 26,
      "Storage": {
        "Prefix": "Multisig",
        "Items": [
          {
            "Name": "Multisigs",
            "Modifier": "Optional",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": "[u8; 32]",
              "Value": "Multisig<T::BlockNumber, BalanceOf<T>, T::AccountId>",
              "IsLinked": true
            },
            "FallBack": "0x00",
            "Documentations": [
              " The set of open multisig operations."
            ]
          },
          {
            "Name": "Calls",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "[u8; 32]",
              "Key2": null,
              "Value": "(OpaqueCall, T::AccountId, BalanceOf<T>)",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [

            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "as_multi_threshold_1",
          "Arguments": [
            {
              "Name": "other_signatories",
              "Type": "Vec<T::AccountId>"
            },
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Immediately dispatch a multi-signature call using a single approval from the caller.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `other_signatories`: The accounts (other than the sender) who are part of the",
            " multi-signature, but do not participate in the approval process.",
            " - `call`: The call to be executed.",
            "",
            " Result is equivalent to the dispatched result.",
            "",
            " # <weight>",
            " O(Z + C) where Z is the length of the call and C its execution weight.",
            " -------------------------------",
            " - DB Weight: None",
            " - Plus Call Weight",
            " # </weight>"
          ]
        },
        {
          "Name": "as_multi",
          "Arguments": [
            {
              "Name": "threshold",
              "Type": "u16"
            },
            {
              "Name": "other_signatories",
              "Type": "Vec<T::AccountId>"
            },
            {
              "Name": "maybe_timepoint",
              "Type": "Option<Timepoint<T::BlockNumber>>"
            },
            {
              "Name": "call",
              "Type": "OpaqueCall"
            },
            {
              "Name": "store_call",
              "Type": "bool"
            },
            {
              "Name": "max_weight",
              "Type": "Weight"
            }
          ],
          "Documentations": [
            " Register approval for a dispatch to be made from a deterministic composite account if",
            " approved by a total of `threshold - 1` of `other_signatories`.",
            "",
            " If there are enough, then dispatch the call.",
            "",
            " Payment: `DepositBase` will be reserved if this is the first approval, plus",
            " `threshold` times `DepositFactor`. It is returned once this dispatch happens or",
            " is cancelled.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `threshold`: The total number of approvals for this dispatch before it is executed.",
            " - `other_signatories`: The accounts (other than the sender) who can approve this",
            " dispatch. May not be empty.",
            " - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is",
            " not the first approval, then it must be `Some`, with the timepoint (block number and",
            " transaction index) of the first approval transaction.",
            " - `call`: The call to be executed.",
            "",
            " NOTE: Unless this is the final approval, you will generally want to use",
            " `approve_as_multi` instead, since it only requires a hash of the call.",
            "",
            " Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise",
            " on success, result is `Ok` and the result from the interior call, if it was executed,",
            " may be found in the deposited `MultisigExecuted` event.",
            "",
            " # <weight>",
            " - `O(S + Z + Call)`.",
            " - Up to one balance-reserve or unreserve operation.",
            " - One passthrough operation, one insert, both `O(S)` where `S` is the number of",
            "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.",
            " - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.",
            " - One encode & hash, both of complexity `O(S)`.",
            " - Up to one binary search and insert (`O(logS + S)`).",
            " - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.",
            " - One event.",
            " - The weight of the `call`.",
            " - Storage: inserts one item, value size bounded by `MaxSignatories`, with a",
            "   deposit taken for its lifetime of",
            "   `DepositBase + threshold * DepositFactor`.",
            " -------------------------------",
            " - DB Weight:",
            "     - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)",
            "     - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)",
            " - Plus Call Weight",
            " # </weight>"
          ]
        },
        {
          "Name": "approve_as_multi",
          "Arguments": [
            {
              "Name": "threshold",
              "Type": "u16"
            },
            {
              "Name": "other_signatories",
              "Type": "Vec<T::AccountId>"
            },
            {
              "Name": "maybe_timepoint",
              "Type": "Option<Timepoint<T::BlockNumber>>"
            },
            {
              "Name": "call_hash",
              "Type": "[u8; 32]"
            },
            {
              "Name": "max_weight",
              "Type": "Weight"
            }
          ],
          "Documentations": [
            " Register approval for a dispatch to be made from a deterministic composite account if",
            " approved by a total of `threshold - 1` of `other_signatories`.",
            "",
            " Payment: `DepositBase` will be reserved if this is the first approval, plus",
            " `threshold` times `DepositFactor`. It is returned once this dispatch happens or",
            " is cancelled.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `threshold`: The total number of approvals for this dispatch before it is executed.",
            " - `other_signatories`: The accounts (other than the sender) who can approve this",
            " dispatch. May not be empty.",
            " - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is",
            " not the first approval, then it must be `Some`, with the timepoint (block number and",
            " transaction index) of the first approval transaction.",
            " - `call_hash`: The hash of the call to be executed.",
            "",
            " NOTE: If this is the final approval, you will want to use `as_multi` instead.",
            "",
            " # <weight>",
            " - `O(S)`.",
            " - Up to one balance-reserve or unreserve operation.",
            " - One passthrough operation, one insert, both `O(S)` where `S` is the number of",
            "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.",
            " - One encode & hash, both of complexity `O(S)`.",
            " - Up to one binary search and insert (`O(logS + S)`).",
            " - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.",
            " - One event.",
            " - Storage: inserts one item, value size bounded by `MaxSignatories`, with a",
            "   deposit taken for its lifetime of",
            "   `DepositBase + threshold * DepositFactor`.",
            " ----------------------------------",
            " - DB Weight:",
            "     - Read: Multisig Storage, [Caller Account]",
            "     - Write: Multisig Storage, [Caller Account]",
            " # </weight>"
          ]
        },
        {
          "Name": "cancel_as_multi",
          "Arguments": [
            {
              "Name": "threshold",
              "Type": "u16"
            },
            {
              "Name": "other_signatories",
              "Type": "Vec<T::AccountId>"
            },
            {
              "Name": "timepoint",
              "Type": "Timepoint<T::BlockNumber>"
            },
            {
              "Name": "call_hash",
              "Type": "[u8; 32]"
            }
          ],
          "Documentations": [
            " Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously",
            " for this operation will be unreserved on success.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `threshold`: The total number of approvals for this dispatch before it is executed.",
            " - `other_signatories`: The accounts (other than the sender) who can approve this",
            " dispatch. May not be empty.",
            " - `timepoint`: The timepoint (block number and transaction index) of the first approval",
            " transaction for this dispatch.",
            " - `call_hash`: The hash of the call to be executed.",
            "",
            " # <weight>",
            " - `O(S)`.",
            " - Up to one balance-reserve or unreserve operation.",
            " - One passthrough operation, one insert, both `O(S)` where `S` is the number of",
            "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.",
            " - One encode & hash, both of complexity `O(S)`.",
            " - One event.",
            " - I/O: 1 read `O(S)`, one remove.",
            " - Storage: removes one item.",
            " ----------------------------------",
            " - DB Weight:",
            "     - Read: Multisig Storage, [Caller Account], Refund Account, Calls",
            "     - Write: Multisig Storage, [Caller Account], Refund Account, Calls",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A new multisig operation has begun. \\[approving, multisig, call_hash\\]"
          ],
          "Name": "NewMultisig",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "CallHash"
          ]
        },
        {
          "Documentations": [
            " A multisig operation has been approved by someone.",
            " \\[approving, timepoint, multisig, call_hash\\]"
          ],
          "Name": "MultisigApproval",
          "EventArgs": [
            "AccountId",
            "Timepoint<BlockNumber>",
            "AccountId",
            "CallHash"
          ]
        },
        {
          "Documentations": [
            " A multisig operation has been executed. \\[approving, timepoint, multisig, call_hash\\]"
          ],
          "Name": "MultisigExecuted",
          "EventArgs": [
            "AccountId",
            "Timepoint<BlockNumber>",
            "AccountId",
            "CallHash",
            "DispatchResult"
          ]
        },
        {
          "Documentations": [
            " A multisig operation has been cancelled. \\[cancelling, timepoint, multisig, call_hash\\]"
          ],
          "Name": "MultisigCancelled",
          "EventArgs": [
            "AccountId",
            "Timepoint<BlockNumber>",
            "AccountId",
            "CallHash"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "DepositBase",
          "Type": "BalanceOf<T>",
          "Value": "0x00F01C0ADBED01000000000000000000",
          "Documentations": [
            " The base amount of currency needed to reserve for creating a multisig execution or to store",
            " a dispatch call for later."
          ]
        },
        {
          "Name": "DepositFactor",
          "Type": "BalanceOf<T>",
          "Value": "0x0000CC7B9FAE00000000000000000000",
          "Documentations": [
            " The amount of currency needed per unit threshold when creating a multisig execution."
          ]
        },
        {
          "Name": "MaxSignatories",
          "Type": "u16",
          "Value": "0x6400",
          "Documentations": [
            " The maximum amount of signatories allowed for a given multisig."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " Threshold must be 2 or greater."
          ],
          "Name": "MinimumThreshold"
        },
        {
          "Documentations": [
            " Call is already approved by this signatory."
          ],
          "Name": "AlreadyApproved"
        },
        {
          "Documentations": [
            " Call doesn't need any (more) approvals."
          ],
          "Name": "NoApprovalsNeeded"
        },
        {
          "Documentations": [
            " There are too few signatories in the list."
          ],
          "Name": "TooFewSignatories"
        },
        {
          "Documentations": [
            " There are too many signatories in the list."
          ],
          "Name": "TooManySignatories"
        },
        {
          "Documentations": [
            " The signatories were provided out of order; they should be ordered."
          ],
          "Name": "SignatoriesOutOfOrder"
        },
        {
          "Documentations": [
            " The sender was contained in the other signatories; it shouldn't be."
          ],
          "Name": "SenderInSignatories"
        },
        {
          "Documentations": [
            " Multisig operation not found when attempting to cancel."
          ],
          "Name": "NotFound"
        },
        {
          "Documentations": [
            " Only the account that originally created the multisig is able to cancel it."
          ],
          "Name": "NotOwner"
        },
        {
          "Documentations": [
            " No timepoint was given, yet the multisig operation is already underway."
          ],
          "Name": "NoTimepoint"
        },
        {
          "Documentations": [
            " A different timepoint was given to the multisig operation that is underway."
          ],
          "Name": "WrongTimepoint"
        },
        {
          "Documentations": [
            " A timepoint was given, yet no multisig operation is underway."
          ],
          "Name": "UnexpectedTimepoint"
        },
        {
          "Documentations": [
            " The maximum weight information provided was too low."
          ],
          "Name": "WeightTooLow"
        },
        {
          "Documentations": [
            " The data to be stored is already stored."
          ],
          "Name": "AlreadyStored"
        }
      ]
    },
    {
      "Name": "Bounties",
      "Index": 27,
      "Storage": {
        "Prefix": "Treasury",
        "Items": [
          {
            "Name": "BountyCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "BountyIndex",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " Number of bounty proposals that have been made."
            ]
          },
          {
            "Name": "Bounties",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "BountyIndex",
              "Key2": null,
              "Value": "Bounty<T::AccountId, BalanceOf<T>, T::BlockNumber>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Bounties that have been made."
            ]
          },
          {
            "Name": "BountyDescriptions",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "BountyIndex",
              "Key2": null,
              "Value": "Vec<u8>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The description of each bounty."
            ]
          },
          {
            "Name": "BountyApprovals",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<BountyIndex>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Bounty indices that have been approved but not yet funded."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "propose_bounty",
          "Arguments": [
            {
              "Name": "value",
              "Type": "Compact<BalanceOf<T>>"
            },
            {
              "Name": "description",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Propose a new bounty.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Payment: `TipReportDepositBase` will be reserved from the origin account, as well as",
            " `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,",
            " or slashed when rejected.",
            "",
            " - `curator`: The curator account whom will manage this bounty.",
            " - `fee`: The curator fee.",
            " - `value`: The total payment amount of this bounty, curator fee included.",
            " - `description`: The description of this bounty."
          ]
        },
        {
          "Name": "approve_bounty",
          "Arguments": [
            {
              "Name": "bounty_id",
              "Type": "Compact<BountyIndex>"
            }
          ],
          "Documentations": [
            " Approve a bounty proposal. At a later time, the bounty will be funded and become active",
            " and the original deposit will be returned.",
            "",
            " May only be called from `T::ApproveOrigin`.",
            "",
            " # <weight>",
            " - O(1).",
            " # </weight>"
          ]
        },
        {
          "Name": "propose_curator",
          "Arguments": [
            {
              "Name": "bounty_id",
              "Type": "Compact<BountyIndex>"
            },
            {
              "Name": "curator",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "fee",
              "Type": "Compact<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Assign a curator to a funded bounty.",
            "",
            " May only be called from `T::ApproveOrigin`.",
            "",
            " # <weight>",
            " - O(1).",
            " # </weight>"
          ]
        },
        {
          "Name": "unassign_curator",
          "Arguments": [
            {
              "Name": "bounty_id",
              "Type": "Compact<BountyIndex>"
            }
          ],
          "Documentations": [
            " Unassign curator from a bounty.",
            "",
            " This function can only be called by the `RejectOrigin` a signed origin.",
            "",
            " If this function is called by the `RejectOrigin`, we assume that the curator is malicious",
            " or inactive. As a result, we will slash the curator when possible.",
            "",
            " If the origin is the curator, we take this as a sign they are unable to do their job and",
            " they willingly give up. We could slash them, but for now we allow them to recover their",
            " deposit and exit without issue. (We may want to change this if it is abused.)",
            "",
            " Finally, the origin can be anyone if and only if the curator is \"inactive\". This allows",
            " anyone in the community to call out that a curator is not doing their due diligence, and",
            " we should pick a new curator. In this case the curator should also be slashed.",
            "",
            " # <weight>",
            " - O(1).",
            " # </weight>"
          ]
        },
        {
          "Name": "accept_curator",
          "Arguments": [
            {
              "Name": "bounty_id",
              "Type": "Compact<BountyIndex>"
            }
          ],
          "Documentations": [
            " Accept the curator role for a bounty.",
            " A deposit will be reserved from curator and refund upon successful payout.",
            "",
            " May only be called from the curator.",
            "",
            " # <weight>",
            " - O(1).",
            " # </weight>"
          ]
        },
        {
          "Name": "award_bounty",
          "Arguments": [
            {
              "Name": "bounty_id",
              "Type": "Compact<BountyIndex>"
            },
            {
              "Name": "beneficiary",
              "Type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "Documentations": [
            " Award bounty to a beneficiary account. The beneficiary will be able to claim the funds after a delay.",
            "",
            " The dispatch origin for this call must be the curator of this bounty.",
            "",
            " - `bounty_id`: Bounty ID to award.",
            " - `beneficiary`: The beneficiary account whom will receive the payout.",
            "",
            " # <weight>",
            " - O(1).",
            " # </weight>"
          ]
        },
        {
          "Name": "claim_bounty",
          "Arguments": [
            {
              "Name": "bounty_id",
              "Type": "Compact<BountyIndex>"
            }
          ],
          "Documentations": [
            " Claim the payout from an awarded bounty after payout delay.",
            "",
            " The dispatch origin for this call must be the beneficiary of this bounty.",
            "",
            " - `bounty_id`: Bounty ID to claim.",
            "",
            " # <weight>",
            " - O(1).",
            " # </weight>"
          ]
        },
        {
          "Name": "close_bounty",
          "Arguments": [
            {
              "Name": "bounty_id",
              "Type": "Compact<BountyIndex>"
            }
          ],
          "Documentations": [
            " Cancel a proposed or active bounty. All the funds will be sent to treasury and",
            " the curator deposit will be unreserved if possible.",
            "",
            " Only `T::RejectOrigin` is able to cancel a bounty.",
            "",
            " - `bounty_id`: Bounty ID to cancel.",
            "",
            " # <weight>",
            " - O(1).",
            " # </weight>"
          ]
        },
        {
          "Name": "extend_bounty_expiry",
          "Arguments": [
            {
              "Name": "bounty_id",
              "Type": "Compact<BountyIndex>"
            },
            {
              "Name": "_remark",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Extend the expiry time of an active bounty.",
            "",
            " The dispatch origin for this call must be the curator of this bounty.",
            "",
            " - `bounty_id`: Bounty ID to extend.",
            " - `remark`: additional information.",
            "",
            " # <weight>",
            " - O(1).",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " New bounty proposal. \\[index\\]"
          ],
          "Name": "BountyProposed",
          "EventArgs": [
            "BountyIndex"
          ]
        },
        {
          "Documentations": [
            " A bounty proposal was rejected; funds were slashed. \\[index, bond\\]"
          ],
          "Name": "BountyRejected",
          "EventArgs": [
            "BountyIndex",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A bounty proposal is funded and became active. \\[index\\]"
          ],
          "Name": "BountyBecameActive",
          "EventArgs": [
            "BountyIndex"
          ]
        },
        {
          "Documentations": [
            " A bounty is awarded to a beneficiary. \\[index, beneficiary\\]"
          ],
          "Name": "BountyAwarded",
          "EventArgs": [
            "BountyIndex",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A bounty is claimed by beneficiary. \\[index, payout, beneficiary\\]"
          ],
          "Name": "BountyClaimed",
          "EventArgs": [
            "BountyIndex",
            "Balance",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A bounty is cancelled. \\[index\\]"
          ],
          "Name": "BountyCanceled",
          "EventArgs": [
            "BountyIndex"
          ]
        },
        {
          "Documentations": [
            " A bounty expiry is extended. \\[index\\]"
          ],
          "Name": "BountyExtended",
          "EventArgs": [
            "BountyIndex"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "DataDepositPerByte",
          "Type": "BalanceOf<T>",
          "Value": "0x0010A5D4E80000000000000000000000",
          "Documentations": [
            " The amount held on deposit per byte within bounty description."
          ]
        },
        {
          "Name": "BountyDepositBase",
          "Type": "BalanceOf<T>",
          "Value": "0x00407A10F35A00000000000000000000",
          "Documentations": [
            " The amount held on deposit for placing a bounty proposal."
          ]
        },
        {
          "Name": "BountyDepositPayoutDelay",
          "Type": "T::BlockNumber",
          "Value": "0x80700000",
          "Documentations": [
            " The delay period for which a bounty beneficiary need to wait before claim the payout."
          ]
        },
        {
          "Name": "BountyUpdatePeriod",
          "Type": "T::BlockNumber",
          "Value": "0x00270600",
          "Documentations": [
            " Bounty duration in blocks."
          ]
        },
        {
          "Name": "BountyCuratorDeposit",
          "Type": "Permill",
          "Value": "0x20A10700",
          "Documentations": [
            " Percentage of the curator fee that will be reserved upfront as deposit for bounty curator."
          ]
        },
        {
          "Name": "BountyValueMinimum",
          "Type": "BalanceOf<T>",
          "Value": "0x00406352BFC601000000000000000000",
          "Documentations": [
            " Minimum value for a bounty."
          ]
        },
        {
          "Name": "MaximumReasonLength",
          "Type": "u32",
          "Value": "0x00400000",
          "Documentations": [
            " Maximum acceptable reason length."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " Proposer's balance is too low."
          ],
          "Name": "InsufficientProposersBalance"
        },
        {
          "Documentations": [
            " No proposal or bounty at that index."
          ],
          "Name": "InvalidIndex"
        },
        {
          "Documentations": [
            " The reason given is just too big."
          ],
          "Name": "ReasonTooBig"
        },
        {
          "Documentations": [
            " The bounty status is unexpected."
          ],
          "Name": "UnexpectedStatus"
        },
        {
          "Documentations": [
            " Require bounty curator."
          ],
          "Name": "RequireCurator"
        },
        {
          "Documentations": [
            " Invalid bounty value."
          ],
          "Name": "InvalidValue"
        },
        {
          "Documentations": [
            " Invalid bounty fee."
          ],
          "Name": "InvalidFee"
        },
        {
          "Documentations": [
            " A bounty payout is pending.",
            " To cancel the bounty, you must unassign and slash the curator."
          ],
          "Name": "PendingPayout"
        },
        {
          "Documentations": [
            " The bounties cannot be claimed/closed because it's still in the countdown period."
          ],
          "Name": "Premature"
        }
      ]
    },
    {
      "Name": "Tips",
      "Index": 28,
      "Storage": {
        "Prefix": "Treasury",
        "Items": [
          {
            "Name": "Tips",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "OpenTip<T::AccountId, BalanceOf<T>, T::BlockNumber, T::Hash>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " TipsMap that are not yet completed. Keyed by the hash of `(reason, who)` from the value.",
              " This has the insecure enumerable hash function since the key itself is already",
              " guaranteed to be a secure hash."
            ]
          },
          {
            "Name": "Reasons",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "Vec<u8>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Simple preimage lookup from the reason's hash to the original data. Again, has an",
              " insecure enumerable hash since the key is guaranteed to be the result of a secure hash."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "report_awesome",
          "Arguments": [
            {
              "Name": "reason",
              "Type": "Vec<u8>"
            },
            {
              "Name": "who",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Report something `reason` that deserves a tip and claim any eventual the finder's fee.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Payment: `TipReportDepositBase` will be reserved from the origin account, as well as",
            " `DataDepositPerByte` for each byte in `reason`.",
            "",
            " - `reason`: The reason for, or the thing that deserves, the tip; generally this will be",
            "   a UTF-8-encoded URL.",
            " - `who`: The account which should be credited for the tip.",
            "",
            " Emits `NewTip` if successful.",
            "",
            " # <weight>",
            " - Complexity: `O(R)` where `R` length of `reason`.",
            "   - encoding and hashing of 'reason'",
            " - DbReads: `Reasons`, `Tips`",
            " - DbWrites: `Reasons`, `Tips`",
            " # </weight>"
          ]
        },
        {
          "Name": "retract_tip",
          "Arguments": [
            {
              "Name": "hash",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.",
            "",
            " If successful, the original deposit will be unreserved.",
            "",
            " The dispatch origin for this call must be _Signed_ and the tip identified by `hash`",
            " must have been reported by the signing account through `report_awesome` (and not",
            " through `tip_new`).",
            "",
            " - `hash`: The identity of the open tip for which a tip value is declared. This is formed",
            "   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.",
            "",
            " Emits `TipRetracted` if successful.",
            "",
            " # <weight>",
            " - Complexity: `O(1)`",
            "   - Depends on the length of `T::Hash` which is fixed.",
            " - DbReads: `Tips`, `origin account`",
            " - DbWrites: `Reasons`, `Tips`, `origin account`",
            " # </weight>"
          ]
        },
        {
          "Name": "tip_new",
          "Arguments": [
            {
              "Name": "reason",
              "Type": "Vec<u8>"
            },
            {
              "Name": "who",
              "Type": "T::AccountId"
            },
            {
              "Name": "tip_value",
              "Type": "Compact<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Give a tip for something new; no finder's fee will be taken.",
            "",
            " The dispatch origin for this call must be _Signed_ and the signing account must be a",
            " member of the `Tippers` set.",
            "",
            " - `reason`: The reason for, or the thing that deserves, the tip; generally this will be",
            "   a UTF-8-encoded URL.",
            " - `who`: The account which should be credited for the tip.",
            " - `tip_value`: The amount of tip that the sender would like to give. The median tip",
            "   value of active tippers will be given to the `who`.",
            "",
            " Emits `NewTip` if successful.",
            "",
            " # <weight>",
            " - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.",
            "   - `O(T)`: decoding `Tipper` vec of length `T`",
            "     `T` is charged as upper bound given by `ContainsLengthBound`.",
            "     The actual cost depends on the implementation of `T::Tippers`.",
            "   - `O(R)`: hashing and encoding of reason of length `R`",
            " - DbReads: `Tippers`, `Reasons`",
            " - DbWrites: `Reasons`, `Tips`",
            " # </weight>"
          ]
        },
        {
          "Name": "tip",
          "Arguments": [
            {
              "Name": "hash",
              "Type": "T::Hash"
            },
            {
              "Name": "tip_value",
              "Type": "Compact<BalanceOf<T>>"
            }
          ],
          "Documentations": [
            " Declare a tip value for an already-open tip.",
            "",
            " The dispatch origin for this call must be _Signed_ and the signing account must be a",
            " member of the `Tippers` set.",
            "",
            " - `hash`: The identity of the open tip for which a tip value is declared. This is formed",
            "   as the hash of the tuple of the hash of the original tip `reason` and the beneficiary",
            "   account ID.",
            " - `tip_value`: The amount of tip that the sender would like to give. The median tip",
            "   value of active tippers will be given to the `who`.",
            "",
            " Emits `TipClosing` if the threshold of tippers has been reached and the countdown period",
            " has started.",
            "",
            " # <weight>",
            " - Complexity: `O(T)` where `T` is the number of tippers.",
            "   decoding `Tipper` vec of length `T`, insert tip and check closing,",
            "   `T` is charged as upper bound given by `ContainsLengthBound`.",
            "   The actual cost depends on the implementation of `T::Tippers`.",
            "",
            "   Actually weight could be lower as it depends on how many tips are in `OpenTip` but it",
            "   is weighted as if almost full i.e of length `T-1`.",
            " - DbReads: `Tippers`, `Tips`",
            " - DbWrites: `Tips`",
            " # </weight>"
          ]
        },
        {
          "Name": "close_tip",
          "Arguments": [
            {
              "Name": "hash",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Close and payout a tip.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " The tip identified by `hash` must have finished its countdown period.",
            "",
            " - `hash`: The identity of the open tip for which a tip value is declared. This is formed",
            "   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.",
            "",
            " # <weight>",
            " - Complexity: `O(T)` where `T` is the number of tippers.",
            "   decoding `Tipper` vec of length `T`.",
            "   `T` is charged as upper bound given by `ContainsLengthBound`.",
            "   The actual cost depends on the implementation of `T::Tippers`.",
            " - DbReads: `Tips`, `Tippers`, `tip finder`",
            " - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`",
            " # </weight>"
          ]
        },
        {
          "Name": "slash_tip",
          "Arguments": [
            {
              "Name": "hash",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Remove and slash an already-open tip.",
            "",
            " May only be called from `T::RejectOrigin`.",
            "",
            " As a result, the finder is slashed and the deposits are lost.",
            "",
            " Emits `TipSlashed` if successful.",
            "",
            " # <weight>",
            "   `T` is charged as upper bound given by `ContainsLengthBound`.",
            "   The actual cost depends on the implementation of `T::Tippers`.",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A new tip suggestion has been opened. \\[tip_hash\\]"
          ],
          "Name": "NewTip",
          "EventArgs": [
            "Hash"
          ]
        },
        {
          "Documentations": [
            " A tip suggestion has reached threshold and is closing. \\[tip_hash\\]"
          ],
          "Name": "TipClosing",
          "EventArgs": [
            "Hash"
          ]
        },
        {
          "Documentations": [
            " A tip suggestion has been closed. \\[tip_hash, who, payout\\]"
          ],
          "Name": "TipClosed",
          "EventArgs": [
            "Hash",
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A tip suggestion has been retracted. \\[tip_hash\\]"
          ],
          "Name": "TipRetracted",
          "EventArgs": [
            "Hash"
          ]
        },
        {
          "Documentations": [
            " A tip suggestion has been slashed. \\[tip_hash, finder, deposit\\]"
          ],
          "Name": "TipSlashed",
          "EventArgs": [
            "Hash",
            "AccountId",
            "Balance"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "TipCountdown",
          "Type": "T::BlockNumber",
          "Value": "0x80700000",
          "Documentations": [
            " The period for which a tip remains open after is has achieved threshold tippers."
          ]
        },
        {
          "Name": "TipFindersFee",
          "Type": "Percent",
          "Value": "0x14",
          "Documentations": [
            " The amount of the final tip which goes to the original reporter of the tip."
          ]
        },
        {
          "Name": "TipReportDepositBase",
          "Type": "BalanceOf<T>",
          "Value": "0x00407A10F35A00000000000000000000",
          "Documentations": [
            " The amount held on deposit for placing a tip report."
          ]
        },
        {
          "Name": "DataDepositPerByte",
          "Type": "BalanceOf<T>",
          "Value": "0x0010A5D4E80000000000000000000000",
          "Documentations": [
            " The amount held on deposit per byte within the tip report reason."
          ]
        },
        {
          "Name": "MaximumReasonLength",
          "Type": "u32",
          "Value": "0x00400000",
          "Documentations": [
            " Maximum acceptable reason length."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " The reason given is just too big."
          ],
          "Name": "ReasonTooBig"
        },
        {
          "Documentations": [
            " The tip was already found/started."
          ],
          "Name": "AlreadyKnown"
        },
        {
          "Documentations": [
            " The tip hash is unknown."
          ],
          "Name": "UnknownTip"
        },
        {
          "Documentations": [
            " The account attempting to retract the tip is not the finder of the tip."
          ],
          "Name": "NotFinder"
        },
        {
          "Documentations": [
            " The tip cannot be claimed/closed because there are not enough tippers yet."
          ],
          "Name": "StillOpen"
        },
        {
          "Documentations": [
            " The tip cannot be claimed/closed because it's still in the countdown period."
          ],
          "Name": "Premature"
        }
      ]
    },
    {
      "Name": "Sudo",
      "Index": 29,
      "Storage": {
        "Prefix": "Sudo",
        "Items": [
          {
            "Name": "Key",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " The `AccountId` of the sudo key."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "sudo",
          "Arguments": [
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Authenticates the sudo key and dispatches a function call with `Root` origin.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " # <weight>",
            " - O(1).",
            " - Limited storage reads.",
            " - One DB write (event).",
            " - Weight of derivative `call` execution + 10,000.",
            " # </weight>"
          ]
        },
        {
          "Name": "sudo_unchecked_weight",
          "Arguments": [
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            },
            {
              "Name": "_weight",
              "Type": "Weight"
            }
          ],
          "Documentations": [
            " Authenticates the sudo key and dispatches a function call with `Root` origin.",
            " This function does not check the weight of the call, and instead allows the",
            " Sudo user to specify the weight of the call.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " # <weight>",
            " - O(1).",
            " - The weight of this call is defined by the caller.",
            " # </weight>"
          ]
        },
        {
          "Name": "set_key",
          "Arguments": [
            {
              "Name": "new",
              "Type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "Documentations": [
            " Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " # <weight>",
            " - O(1).",
            " - Limited storage reads.",
            " - One DB change.",
            " # </weight>"
          ]
        },
        {
          "Name": "sudo_as",
          "Arguments": [
            {
              "Name": "who",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Authenticates the sudo key and dispatches a function call with `Signed` origin from",
            " a given account.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " # <weight>",
            " - O(1).",
            " - Limited storage reads.",
            " - One DB write (event).",
            " - Weight of derivative `call` execution + 10,000.",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A sudo just took place. \\[result\\]"
          ],
          "Name": "Sudid",
          "EventArgs": [
            "DispatchResult"
          ]
        },
        {
          "Documentations": [
            " The \\[sudoer\\] just switched identity; the old key is supplied."
          ],
          "Name": "KeyChanged",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A sudo just took place. \\[result\\]"
          ],
          "Name": "SudoAsDone",
          "EventArgs": [
            "DispatchResult"
          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [
        {
          "Documentations": [
            " Sender must be the Sudo account"
          ],
          "Name": "RequireSudo"
        }
      ]
    },
    {
      "Name": "DotMogModule",
      "Index": 30,
      "Storage": {
        "Prefix": "DotMogModule",
        "Items": [
          {
            "Name": "Something",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [

            ]
          },
          {
            "Name": "Key",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " The `AccountId` of the dot mog founder."
            ]
          },
          {
            "Name": "AccountConfig",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "Vec<u8>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A map of the current configuration of an account."
            ]
          },
          {
            "Name": "Mogwais",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "MogwaiStruct<T::Hash, T::BlockNumber, BalanceOf<T>, RarityType>",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " A map of mogwais accessible by the mogwai hash."
            ]
          },
          {
            "Name": "MogwaisBios",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "MogwaiBios<T::Hash, T::BlockNumber, BalanceOf<T>>",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " A map of mogwai bios accessible by the mogwai hash."
            ]
          },
          {
            "Name": "MogwaiOwner",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A map of mogwai owners accessible by the mogwai hash."
            ]
          },
          {
            "Name": "AllMogwaisArray",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "u64",
              "Key2": null,
              "Value": "T::Hash",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " A map of all existing mogwais accessible by the index. "
            ]
          },
          {
            "Name": "AllMogwaisCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u64",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " A count over all existing mogwais in the system."
            ]
          },
          {
            "Name": "AllMogwaisIndex",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "u64",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " A map of the index of the mogwai accessible by the mogwai hash."
            ]
          },
          {
            "Name": "OwnedMogwaisArray",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "(T::AccountId, u64)",
              "Key2": null,
              "Value": "T::Hash",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " A map of all mogwai hashes associated with an account."
            ]
          },
          {
            "Name": "OwnedMogwaisCount",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "u64",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " A count over all existing mogwais owned by one account."
            ]
          },
          {
            "Name": "OwnedMogwaisIndex",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "u64",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " A map of the owned mogwais index accessible by the mogwai hash."
            ]
          },
          {
            "Name": "MogwaiAuction",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "Auction<T::Hash, BalanceOf<T>, T::BlockNumber, T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A map of mogwai auctions accessible by the mogwai hash."
            ]
          },
          {
            "Name": "Auctions",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::BlockNumber",
              "Key2": null,
              "Value": "Vec<Auction<T::Hash, BalanceOf<T>, T::BlockNumber, T::AccountId>\n>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A vec of mogwai auctions accessible by the expiry block number. "
            ]
          },
          {
            "Name": "AuctionPeriodLimit",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::BlockNumber",
              "IsLinked": false
            },
            "FallBack": "0xE8030000",
            "Documentations": [
              " Current auction period max limit.       "
            ]
          },
          {
            "Name": "Bids",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "(T::Hash, T::AccountId)",
              "Key2": null,
              "Value": "BalanceOf<T>",
              "IsLinked": false
            },
            "FallBack": "0x00000000000000000000000000000000",
            "Documentations": [
              " A map of bids accessible by account id and mogwai hash."
            ]
          },
          {
            "Name": "BidAccounts",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "Vec<T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A vec of accounts accessible by mogwai hash."
            ]
          },
          {
            "Name": "GameEvents",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "GameEvent<T::Hash, T::BlockNumber, GameEventType>",
              "IsLinked": false
            },
            "FallBack": "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " A map of game events accessible by the game event id (hash)."
            ]
          },
          {
            "Name": "AllGameEventsArray",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "u64",
              "Key2": null,
              "Value": "T::Hash",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " A map of all existing game events accessible by the index. "
            ]
          },
          {
            "Name": "AllGameEventsCount",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u64",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " A count over all existing game events in the system."
            ]
          },
          {
            "Name": "AllGameEventsIndex",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "u64",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " A map of the index of the game events accessible by the game event id (hash)."
            ]
          },
          {
            "Name": "GameEventsArray",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "(GameEventType, u64)",
              "Key2": null,
              "Value": "T::Hash",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " A map of all game event ids (hash) associated with an game event type (indexed)."
            ]
          },
          {
            "Name": "GameEventsCount",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "GameEventType",
              "Key2": null,
              "Value": "u64",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " A count over all existing game events of one particular game event type."
            ]
          },
          {
            "Name": "GameEventsIndex",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "u64",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " A map of the game event type index accessible by the game event id (hash)."
            ]
          },
          {
            "Name": "GameEventsAtBlock",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::BlockNumber",
              "Key2": null,
              "Value": "Vec<T::Hash>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A vec of game event ids (hash) accessible by the triggering block number."
            ]
          },
          {
            "Name": "GameEventsOfMogwai",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "T::Hash",
              "Key2": null,
              "Value": "Vec<T::Hash>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A vec of game event ids (hash) accessible by the corresponding mogwai."
            ]
          },
          {
            "Name": "Nonce",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u64",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " The nonce used for randomness."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "do_something",
          "Arguments": [
            {
              "Name": "something",
              "Type": "u32"
            }
          ],
          "Documentations": [
            " An example dispatchable that takes a singles value as a parameter, writes the value to",
            " storage and emits an event. This function must be dispatched by a signed extrinsic."
          ]
        },
        {
          "Name": "cause_error",
          "Arguments": [

          ],
          "Documentations": [
            " An example dispatchable that may throw a custom error."
          ]
        },
        {
          "Name": "update_config",
          "Arguments": [
            {
              "Name": "index",
              "Type": "u8"
            },
            {
              "Name": "value_opt",
              "Type": "Option<u8>"
            }
          ],
          "Documentations": [

          ]
        },
        {
          "Name": "set_price",
          "Arguments": [
            {
              "Name": "mogwai_id",
              "Type": "T::Hash"
            },
            {
              "Name": "new_price",
              "Type": "BalanceOf<T>"
            }
          ],
          "Documentations": [
            " Set price of mogwai."
          ]
        },
        {
          "Name": "create_mogwai",
          "Arguments": [

          ],
          "Documentations": [
            " Create a new mogwai."
          ]
        },
        {
          "Name": "remove_mogwai",
          "Arguments": [
            {
              "Name": "mogwai_id",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Remove an old mogwai."
          ]
        },
        {
          "Name": "transfer",
          "Arguments": [
            {
              "Name": "to",
              "Type": "T::AccountId"
            },
            {
              "Name": "mogwai_id",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Transfer mogwai to a new account."
          ]
        },
        {
          "Name": "sacrifice",
          "Arguments": [
            {
              "Name": "mogwai_id_1",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Sacrifice mogwai to an other mogwai."
          ]
        },
        {
          "Name": "buy_mogwai",
          "Arguments": [
            {
              "Name": "mogwai_id",
              "Type": "T::Hash"
            },
            {
              "Name": "max_price",
              "Type": "BalanceOf<T>"
            }
          ],
          "Documentations": [
            " Buy a mogwai."
          ]
        },
        {
          "Name": "morph_mogwai",
          "Arguments": [
            {
              "Name": "mogwai_id",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Morph a gen 0 mogwai"
          ]
        },
        {
          "Name": "breed_mogwai",
          "Arguments": [
            {
              "Name": "mogwai_id_1",
              "Type": "T::Hash"
            },
            {
              "Name": "mogwai_id_2",
              "Type": "T::Hash"
            }
          ],
          "Documentations": [
            " Breed a mogwai."
          ]
        },
        {
          "Name": "create_auction",
          "Arguments": [
            {
              "Name": "mogwai_id",
              "Type": "T::Hash"
            },
            {
              "Name": "min_bid",
              "Type": "BalanceOf<T>"
            },
            {
              "Name": "expiry",
              "Type": "T::BlockNumber"
            }
          ],
          "Documentations": [
            " Create a new auction."
          ]
        },
        {
          "Name": "bid_auction",
          "Arguments": [
            {
              "Name": "mogwai_id",
              "Type": "T::Hash"
            },
            {
              "Name": "bid",
              "Type": "BalanceOf<T>"
            }
          ],
          "Documentations": [
            " Bid on an auction."
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " Event documentation should end with an array that provides descriptive names for event",
            " parameters. [something, who]"
          ],
          "Name": "SomethingStored",
          "EventArgs": [
            "u32",
            "AccountId"
          ]
        },
        {
          "Documentations": [

          ],
          "Name": "AccountConfigChanged",
          "EventArgs": [
            "AccountId",
            "Vec<u8>"
          ]
        },
        {
          "Documentations": [
            " A mogwai has been created."
          ],
          "Name": "MogwaiCreated",
          "EventArgs": [
            "AccountId",
            "Hash"
          ]
        },
        {
          "Documentations": [
            " A mogwai has been removed. (R.I.P.)"
          ],
          "Name": "MogwaiRemoved",
          "EventArgs": [
            "AccountId",
            "Hash"
          ]
        },
        {
          "Documentations": [
            " A price has been set for a mogwai."
          ],
          "Name": "PriceSet",
          "EventArgs": [
            "AccountId",
            "Hash",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A mogwai changed his owner."
          ],
          "Name": "Transferred",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "Hash"
          ]
        },
        {
          "Documentations": [
            " A mogwai has been was bought."
          ],
          "Name": "Bought",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "Hash",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A auction has been created"
          ],
          "Name": "AuctionCreated",
          "EventArgs": [
            "Hash",
            "Balance",
            "BlockNumber"
          ]
        },
        {
          "Documentations": [
            " A bid has been placed."
          ],
          "Name": "Bid",
          "EventArgs": [
            "Hash",
            "Balance",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A auction hash been finalized."
          ],
          "Name": "AuctionFinalized",
          "EventArgs": [
            "Hash",
            "Balance",
            "BlockNumber"
          ]
        },
        {
          "Documentations": [
            " A game event hash been created."
          ],
          "Name": "GameEventCreated",
          "EventArgs": [
            "AccountId",
            "Hash"
          ]
        },
        {
          "Documentations": [
            " A game event hash been executed."
          ],
          "Name": "GameEventExecuted",
          "EventArgs": [
            "Hash"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "ModuleId",
          "Type": "ModuleId",
          "Value": "0x70792F64746D6F67",
          "Documentations": [

          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " Error names should be descriptive."
          ],
          "Name": "NoneValue"
        },
        {
          "Documentations": [
            " A Storage overflow, has occured make sure to validate first."
          ],
          "Name": "StorageOverflow"
        },
        {
          "Documentations": [
            " The mogwai id (hash) already exists."
          ],
          "Name": "MogwaiAlreadyExists"
        },
        {
          "Documentations": [
            " The mogwais hash doesn't exist."
          ],
          "Name": "MogwaiDoesntExists"
        },
        {
          "Documentations": [
            " The mogwai has pending game events."
          ],
          "Name": "MogwaiHasGameEvents"
        },
        {
          "Documentations": [
            " The mogwai isn't owned by the sender."
          ],
          "Name": "MogwaiNotOwned"
        },
        {
          "Documentations": [
            " The submitted index is out of range."
          ],
          "Name": "ConfigIndexOutOfRange"
        },
        {
          "Documentations": [
            " Incompatible generation"
          ],
          "Name": "MogwaiIncompatibleGeneration"
        },
        {
          "Documentations": [

          ],
          "Name": "MogwaiHasNoBios"
        },
        {
          "Documentations": [
            " The game event id (hash) already exists."
          ],
          "Name": "GameEventAlreadyExists"
        }
      ]
    },
    {
      "Name": "DotMogBase",
      "Index": 31,
      "Storage": {
        "Prefix": "DotMogBase",
        "Items": [
          {
            "Name": "Something",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [

            ]
          },
          {
            "Name": "Key",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [
              " The current authority set."
            ]
          },
          {
            "Name": "AccountClaim",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "(T::AccountId, Vec<u8>)",
              "Key2": null,
              "Value": "MogwaicoinAddress<T::AccountId, ClaimState, BalanceOf<T>>",
              "IsLinked": false
            },
            "FallBack": "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "Documentations": [

            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "do_something",
          "Arguments": [
            {
              "Name": "something",
              "Type": "u32"
            }
          ],
          "Documentations": [
            " An example dispatchable that takes a singles value as a parameter, writes the value to",
            " storage and emits an event. This function must be dispatched by a signed extrinsic."
          ]
        },
        {
          "Name": "change_key",
          "Arguments": [
            {
              "Name": "to",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [

          ]
        },
        {
          "Name": "claim",
          "Arguments": [
            {
              "Name": "address",
              "Type": "Vec<u8>"
            },
            {
              "Name": "account",
              "Type": "T::AccountId"
            },
            {
              "Name": "signature",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [

          ]
        },
        {
          "Name": "update_claim",
          "Arguments": [
            {
              "Name": "address",
              "Type": "Vec<u8>"
            },
            {
              "Name": "account",
              "Type": "T::AccountId"
            },
            {
              "Name": "state",
              "Type": "u32"
            },
            {
              "Name": "balance",
              "Type": "BalanceOf<T>"
            }
          ],
          "Documentations": [

          ]
        },
        {
          "Name": "remove_claim",
          "Arguments": [
            {
              "Name": "address",
              "Type": "Vec<u8>"
            },
            {
              "Name": "account",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [

          ]
        },
        {
          "Name": "cause_error",
          "Arguments": [

          ],
          "Documentations": [
            " An example dispatchable that may throw a custom error."
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " Event documentation should end with an array that provides descriptive names for event",
            " parameters. [something, who]"
          ],
          "Name": "SomethingStored",
          "EventArgs": [
            "u32",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " Key for claim registrations changed",
            " parameters. [who] "
          ],
          "Name": "KeyChanged",
          "EventArgs": [
            "AccountId"
          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [
        {
          "Documentations": [
            " Error names should be descriptive."
          ],
          "Name": "NoneValue"
        },
        {
          "Documentations": [
            " Errors should have helpful documentation associated with them."
          ],
          "Name": "StorageOverflow"
        },
        {
          "Documentations": [
            " Account is already claimed."
          ],
          "Name": "AccountClaimAlreadyExists"
        },
        {
          "Documentations": [
            " Account doesn't exists."
          ],
          "Name": "AccountClaimDoesntExists"
        },
        {
          "Documentations": [
            " Incorrect signature size."
          ],
          "Name": "SignatureSize"
        },
        {
          "Documentations": [
            " Incorrect address size."
          ],
          "Name": "AddressSize"
        }
      ]
    },
    {
      "Name": "Contracts",
      "Index": 32,
      "Storage": {
        "Prefix": "Contracts",
        "Items": [
          {
            "Name": "CurrentSchedule",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Schedule<T>",
              "IsLinked": false
            },
            "FallBack": "0x0000000000040000000002000000010000800000001000000000100000000100002000000000000800150600004C6B02004C8103009E1800000B1D0000160D0000651800006D2B00008A000000F5700100FDF602008E070000440600006E070000030600004F180000B528000091070000B60DA70827080000590800006A0A0000EF070000560800004A0800008E080000F509000061090000DD090000A10A00009C090000E409000091090000650900001E0A0000120A0000AE09000099090000060A00006B2000000B1D000051200000221D000094090000AD090000B6090000160A0000660A0000FD090000260A0000440A0000D41A2A0000000000A0C729000000000092122900000000001AB5580000000000BA1C290000000000E000290000000000B0EF280000000000EE325C0000000000DEC1280000000000CA07290000000000C07D4E00000000009C77140000000000303A7200000000000B01000000000000F0AB450000000000FF0200000000000060A21C270000000030078D31000000002635AF09000000000AE164000000000038B18E0000000000B6B1CC0700000000890900000000000040036C00000000008AD6E21100000000DE020000000000006E67CC080000000078F6110200000000E605000000000000ACB1B50A00000000B24419090000000092579F08000000004702000000000000240300000000000016EAEB220000000055020000000000003503000000000000DB0A000000000000F4802600000000006A100000000000006A9A280000000000220D0000000000004E9C2400000000001C0600000000000026832400000000001B06000000000000",
            "Documentations": [
              " Current cost schedule for contracts."
            ]
          },
          {
            "Name": "PristineCode",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "CodeHash<T>",
              "Key2": null,
              "Value": "Vec<u8>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A mapping from an original code hash to the original code, untouched by instrumentation."
            ]
          },
          {
            "Name": "CodeStorage",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Identity",
              "Key1": "CodeHash<T>",
              "Key2": null,
              "Value": "PrefabWasmModule<T>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A mapping between an original code hash and instrumented wasm code, ready for execution."
            ]
          },
          {
            "Name": "AccountCounter",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u64",
              "IsLinked": false
            },
            "FallBack": "0x0000000000000000",
            "Documentations": [
              " The subtrie counter."
            ]
          },
          {
            "Name": "ContractInfoOf",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "ContractInfo<T>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The code associated with a given account.",
              "",
              " TWOX-NOTE: SAFE since `AccountId` is a secure hash."
            ]
          },
          {
            "Name": "DeletionQueue",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<storage::DeletedContract>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Evicted contracts that await child trie deletion.",
              "",
              " Child trie deletion is a heavy operation depending on the amount of storage items",
              " stored in said trie. Therefore this operation is performed lazily in `on_initialize`."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "update_schedule",
          "Arguments": [
            {
              "Name": "schedule",
              "Type": "Schedule<T>"
            }
          ],
          "Documentations": [
            " Updates the schedule for metering contracts.",
            "",
            " The schedule must have a greater version than the stored schedule."
          ]
        },
        {
          "Name": "call",
          "Arguments": [
            {
              "Name": "dest",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "value",
              "Type": "Compact<BalanceOf<T>>"
            },
            {
              "Name": "gas_limit",
              "Type": "Compact<Gas>"
            },
            {
              "Name": "data",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Makes a call to an account, optionally transferring some balance.",
            "",
            " * If the account is a smart-contract account, the associated code will be",
            " executed and any value will be transferred.",
            " * If the account is a regular account, any value will be transferred.",
            " * If no account exists and the call value is not less than `existential_deposit`,",
            " a regular account will be created and any value will be transferred."
          ]
        },
        {
          "Name": "instantiate_with_code",
          "Arguments": [
            {
              "Name": "endowment",
              "Type": "Compact<BalanceOf<T>>"
            },
            {
              "Name": "gas_limit",
              "Type": "Compact<Gas>"
            },
            {
              "Name": "code",
              "Type": "Vec<u8>"
            },
            {
              "Name": "data",
              "Type": "Vec<u8>"
            },
            {
              "Name": "salt",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Instantiates a new contract from the supplied `code` optionally transferring",
            " some balance.",
            "",
            " This is the only function that can deploy new code to the chain.",
            "",
            " # Parameters",
            "",
            " * `endowment`: The balance to transfer from the `origin` to the newly created contract.",
            " * `gas_limit`: The gas limit enforced when executing the constructor.",
            " * `code`: The contract code to deploy in raw bytes.",
            " * `data`: The input data to pass to the contract constructor.",
            " * `salt`: Used for the address derivation. See [`Self::contract_address`].",
            "",
            " Instantiation is executed as follows:",
            "",
            " - The supplied `code` is instrumented, deployed, and a `code_hash` is created for that code.",
            " - If the `code_hash` already exists on the chain the underlying `code` will be shared.",
            " - The destination address is computed based on the sender, code_hash and the salt.",
            " - The smart-contract account is created at the computed address.",
            " - The `endowment` is transferred to the new account.",
            " - The `deploy` function is executed in the context of the newly-created account."
          ]
        },
        {
          "Name": "instantiate",
          "Arguments": [
            {
              "Name": "endowment",
              "Type": "Compact<BalanceOf<T>>"
            },
            {
              "Name": "gas_limit",
              "Type": "Compact<Gas>"
            },
            {
              "Name": "code_hash",
              "Type": "CodeHash<T>"
            },
            {
              "Name": "data",
              "Type": "Vec<u8>"
            },
            {
              "Name": "salt",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Instantiates a contract from a previously deployed wasm binary.",
            "",
            " This function is identical to [`Self::instantiate_with_code`] but without the",
            " code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary",
            " must be supplied."
          ]
        },
        {
          "Name": "claim_surcharge",
          "Arguments": [
            {
              "Name": "dest",
              "Type": "T::AccountId"
            },
            {
              "Name": "aux_sender",
              "Type": "Option<T::AccountId>"
            }
          ],
          "Documentations": [
            " Allows block producers to claim a small reward for evicting a contract. If a block",
            " producer fails to do so, a regular users will be allowed to claim the reward.",
            "",
            " In case of a successful eviction no fees are charged from the sender. However, the",
            " reward is capped by the total amount of rent that was payed by the contract while",
            " it was alive.",
            "",
            " If contract is not evicted as a result of this call, [`Error::ContractNotEvictable`]",
            " is returned and the sender is not eligible for the reward."
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " Contract deployed by address at the specified address. \\[deployer, contract\\]"
          ],
          "Name": "Instantiated",
          "EventArgs": [
            "AccountId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " Contract has been evicted and is now in tombstone state. \\[contract\\]"
          ],
          "Name": "Evicted",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " Contract has been terminated without leaving a tombstone.",
            " \\[contract, beneficiary\\]",
            "",
            " # Params",
            "",
            " - `contract`: The contract that was terminated.",
            " - `beneficiary`: The account that received the contracts remaining balance.",
            "",
            " # Note",
            "",
            " The only way for a contract to be removed without a tombstone and emitting",
            " this event is by calling `seal_terminate`."
          ],
          "Name": "Terminated",
          "EventArgs": [
            "AccountId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " Restoration of a contract has been successful.",
            " \\[restorer, dest, code_hash, rent_allowance\\]",
            "",
            " # Params",
            "",
            " - `restorer`: Account ID of the restoring contract.",
            " - `dest`: Account ID of the restored contract.",
            " - `code_hash`: Code hash of the restored contract.",
            " - `rent_allowance`: Rent allowance of the restored contract."
          ],
          "Name": "Restored",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "Hash",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Code with the specified hash has been stored. \\[code_hash\\]"
          ],
          "Name": "CodeStored",
          "EventArgs": [
            "Hash"
          ]
        },
        {
          "Documentations": [
            " Triggered when the current schedule is updated.",
            " \\[version\\]",
            "",
            " # Params",
            "",
            " - `version`: The version of the newly set schedule."
          ],
          "Name": "ScheduleUpdated",
          "EventArgs": [
            "u32"
          ]
        },
        {
          "Documentations": [
            " A custom event emitted by the contract.",
            " \\[contract, data\\]",
            "",
            " # Params",
            "",
            " - `contract`: The contract that emitted the event.",
            " - `data`: Data supplied by the contract. Metadata generated during contract",
            "           compilation is needed to decode it."
          ],
          "Name": "ContractEmitted",
          "EventArgs": [
            "AccountId",
            "Vec<u8>"
          ]
        },
        {
          "Documentations": [
            " A code with the specified hash was removed.",
            " \\[code_hash\\]",
            "",
            " This happens when the last contract that uses this code hash was removed or evicted."
          ],
          "Name": "CodeRemoved",
          "EventArgs": [
            "Hash"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "SignedClaimHandicap",
          "Type": "T::BlockNumber",
          "Value": "0x02000000",
          "Documentations": [
            " Number of block delay an extrinsic claim surcharge has.",
            "",
            " When claim surcharge is called by an extrinsic the rent is checked",
            " for current_block - delay"
          ]
        },
        {
          "Name": "TombstoneDeposit",
          "Type": "BalanceOf<T>",
          "Value": "0x00F002C82A4502000000000000000000",
          "Documentations": [
            " The minimum amount required to generate a tombstone."
          ]
        },
        {
          "Name": "DepositPerContract",
          "Type": "BalanceOf<T>",
          "Value": "0x00F002C82A4502000000000000000000",
          "Documentations": [
            " The balance every contract needs to deposit to stay alive indefinitely.",
            "",
            " This is different from the [`Self::TombstoneDeposit`] because this only needs to be",
            " deposited while the contract is alive. Costs for additional storage are added to",
            " this base cost.",
            "",
            " This is a simple way to ensure that contracts with empty storage eventually get deleted by",
            " making them pay rent. This creates an incentive to remove them early in order to save rent."
          ]
        },
        {
          "Name": "DepositPerStorageByte",
          "Type": "BalanceOf<T>",
          "Value": "0x0060DEFB740500000000000000000000",
          "Documentations": [
            " The balance a contract needs to deposit per storage byte to stay alive indefinitely.",
            "",
            " Let's suppose the deposit is 1,000 BU (balance units)/byte and the rent is 1 BU/byte/day,",
            " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.",
            " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,",
            " then it would pay 500 BU/day."
          ]
        },
        {
          "Name": "DepositPerStorageItem",
          "Type": "BalanceOf<T>",
          "Value": "0x00F0AB75A40D00000000000000000000",
          "Documentations": [
            " The balance a contract needs to deposit per storage item to stay alive indefinitely.",
            "",
            " It works the same as [`Self::DepositPerStorageByte`] but for storage items."
          ]
        },
        {
          "Name": "RentFraction",
          "Type": "Perbill",
          "Value": "0x85040000",
          "Documentations": [
            " The fraction of the deposit that should be used as rent per block.",
            "",
            " When a contract hasn't enough balance deposited to stay alive indefinitely it needs",
            " to pay per block for the storage it consumes that is not covered by the deposit.",
            " This determines how high this rent payment is per block as a fraction of the deposit."
          ]
        },
        {
          "Name": "SurchargeReward",
          "Type": "BalanceOf<T>",
          "Value": "0x005CB2EC220000000000000000000000",
          "Documentations": [
            " Reward that is received by the party whose touch has led",
            " to removal of a contract."
          ]
        },
        {
          "Name": "MaxDepth",
          "Type": "u32",
          "Value": "0x20000000",
          "Documentations": [
            " The maximum nesting level of a call/instantiate stack. A reasonable default",
            " value is 100."
          ]
        },
        {
          "Name": "MaxValueSize",
          "Type": "u32",
          "Value": "0x00400000",
          "Documentations": [
            " The maximum size of a storage value in bytes. A reasonable default is 16 KiB."
          ]
        },
        {
          "Name": "DeletionQueueDepth",
          "Type": "u32",
          "Value": "0xF2000000",
          "Documentations": [
            " The maximum number of tries that can be queued for deletion."
          ]
        },
        {
          "Name": "DeletionWeightLimit",
          "Type": "Weight",
          "Value": "0x00D0ED902E000000",
          "Documentations": [
            " The maximum amount of weight that can be consumed per block for lazy trie removal."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " A new schedule must have a greater version than the current one."
          ],
          "Name": "InvalidScheduleVersion"
        },
        {
          "Documentations": [
            " An origin must be signed or inherent and auxiliary sender only provided on inherent."
          ],
          "Name": "InvalidSurchargeClaim"
        },
        {
          "Documentations": [
            " Cannot restore from nonexisting or tombstone contract."
          ],
          "Name": "InvalidSourceContract"
        },
        {
          "Documentations": [
            " Cannot restore to nonexisting or alive contract."
          ],
          "Name": "InvalidDestinationContract"
        },
        {
          "Documentations": [
            " Tombstones don't match."
          ],
          "Name": "InvalidTombstone"
        },
        {
          "Documentations": [
            " An origin TrieId written in the current block."
          ],
          "Name": "InvalidContractOrigin"
        },
        {
          "Documentations": [
            " The executed contract exhausted its gas limit."
          ],
          "Name": "OutOfGas"
        },
        {
          "Documentations": [
            " The output buffer supplied to a contract API call was too small."
          ],
          "Name": "OutputBufferTooSmall"
        },
        {
          "Documentations": [
            " Performing the requested transfer would have brought the contract below",
            " the subsistence threshold. No transfer is allowed to do this in order to allow",
            " for a tombstone to be created. Use `seal_terminate` to remove a contract without",
            " leaving a tombstone behind."
          ],
          "Name": "BelowSubsistenceThreshold"
        },
        {
          "Documentations": [
            " The newly created contract is below the subsistence threshold after executing",
            " its contructor. No contracts are allowed to exist below that threshold."
          ],
          "Name": "NewContractNotFunded"
        },
        {
          "Documentations": [
            " Performing the requested transfer failed for a reason originating in the",
            " chosen currency implementation of the runtime. Most probably the balance is",
            " too low or locks are placed on it."
          ],
          "Name": "TransferFailed"
        },
        {
          "Documentations": [
            " Performing a call was denied because the calling depth reached the limit",
            " of what is specified in the schedule."
          ],
          "Name": "MaxCallDepthReached"
        },
        {
          "Documentations": [
            " The contract that was called is either no contract at all (a plain account)",
            " or is a tombstone."
          ],
          "Name": "NotCallable"
        },
        {
          "Documentations": [
            " The code supplied to `instantiate_with_code` exceeds the limit specified in the",
            " current schedule."
          ],
          "Name": "CodeTooLarge"
        },
        {
          "Documentations": [
            " No code could be found at the supplied code hash."
          ],
          "Name": "CodeNotFound"
        },
        {
          "Documentations": [
            " A buffer outside of sandbox memory was passed to a contract API function."
          ],
          "Name": "OutOfBounds"
        },
        {
          "Documentations": [
            " Input passed to a contract API function failed to decode as expected type."
          ],
          "Name": "DecodingFailed"
        },
        {
          "Documentations": [
            " Contract trapped during execution."
          ],
          "Name": "ContractTrapped"
        },
        {
          "Documentations": [
            " The size defined in `T::MaxValueSize` was exceeded."
          ],
          "Name": "ValueTooLarge"
        },
        {
          "Documentations": [
            " The action performed is not allowed while the contract performing it is already",
            " on the call stack. Those actions are contract self destruction and restoration",
            " of a tombstone."
          ],
          "Name": "ReentranceDenied"
        },
        {
          "Documentations": [
            " `seal_input` was called twice from the same contract execution context."
          ],
          "Name": "InputAlreadyRead"
        },
        {
          "Documentations": [
            " The subject passed to `seal_random` exceeds the limit."
          ],
          "Name": "RandomSubjectTooLong"
        },
        {
          "Documentations": [
            " The amount of topics passed to `seal_deposit_events` exceeds the limit."
          ],
          "Name": "TooManyTopics"
        },
        {
          "Documentations": [
            " The topics passed to `seal_deposit_events` contains at least one duplicate."
          ],
          "Name": "DuplicateTopics"
        },
        {
          "Documentations": [
            " The chain does not provide a chain extension. Calling the chain extension results",
            " in this error. Note that this usually  shouldn't happen as deploying such contracts",
            " is rejected."
          ],
          "Name": "NoChainExtension"
        },
        {
          "Documentations": [
            " Removal of a contract failed because the deletion queue is full.",
            "",
            " This can happen when either calling [`Module::claim_surcharge`] or `seal_terminate`.",
            " The queue is filled by deleting contracts and emptied by a fixed amount each block.",
            " Trying again during another block is the only way to resolve this issue."
          ],
          "Name": "DeletionQueueFull"
        },
        {
          "Documentations": [
            " A contract could not be evicted because it has enough balance to pay rent.",
            "",
            " This can be returned from [`Module::claim_surcharge`] because the target",
            " contract has enough balance to pay for its rent."
          ],
          "Name": "ContractNotEvictable"
        },
        {
          "Documentations": [
            " A storage modification exhausted the 32bit type that holds the storage size.",
            "",
            " This can either happen when the accumulated storage in bytes is too large or",
            " when number of storage items is too large."
          ],
          "Name": "StorageExhausted"
        },
        {
          "Documentations": [
            " A contract with the same AccountId already exists."
          ],
          "Name": "DuplicateContract"
        }
      ]
    },
    {
      "Name": "Society",
      "Index": 33,
      "Storage": {
        "Prefix": "Society",
        "Items": [
          {
            "Name": "Founder",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The first member."
            ]
          },
          {
            "Name": "Rules",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::Hash",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " A hash of the rules of this society concerning membership. Can only be set once and",
              " only by the founder."
            ]
          },
          {
            "Name": "Candidates",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<Bid<T::AccountId, BalanceOf<T, I>>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current set of candidates; bidders that are attempting to become members."
            ]
          },
          {
            "Name": "SuspendedCandidates",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "(BalanceOf<T, I>, BidKind<T::AccountId, BalanceOf<T, I>>)",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The set of suspended candidates."
            ]
          },
          {
            "Name": "Pot",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "BalanceOf<T, I>",
              "IsLinked": false
            },
            "FallBack": "0x00000000000000000000000000000000",
            "Documentations": [
              " Amount of our account balance that is specifically for the next round's bid(s)."
            ]
          },
          {
            "Name": "Head",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The most primary from the most recently approved members."
            ]
          },
          {
            "Name": "Members",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current set of members, ordered."
            ]
          },
          {
            "Name": "SuspendedMembers",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "bool",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The set of suspended members."
            ]
          },
          {
            "Name": "Bids",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "Vec<Bid<T::AccountId, BalanceOf<T, I>>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The current bids, stored ordered by the value of the bid."
            ]
          },
          {
            "Name": "Vouching",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "VouchingStatus",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Members currently vouching or banned from vouching again"
            ]
          },
          {
            "Name": "Payouts",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "Vec<(T::BlockNumber, BalanceOf<T, I>)>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Pending payouts; ordered by block number, with the amount that should be paid out."
            ]
          },
          {
            "Name": "Strikes",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "StrikeCount",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " The ongoing number of losing votes cast by the member."
            ]
          },
          {
            "Name": "Votes",
            "Modifier": "Optional",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": "T::AccountId",
              "Value": "Vote",
              "IsLinked": true
            },
            "FallBack": "0x00",
            "Documentations": [
              " Double map from Candidate -> Voter -> (Maybe) Vote."
            ]
          },
          {
            "Name": "Defender",
            "Modifier": "Optional",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The defending member currently being challenged."
            ]
          },
          {
            "Name": "DefenderVotes",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "Vote",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Votes for the defender."
            ]
          },
          {
            "Name": "MaxMembers",
            "Modifier": "Default",
            "Type": "Plain",
            "Function": {
              "Hasher": "None",
              "Key1": null,
              "Key2": null,
              "Value": "u32",
              "IsLinked": false
            },
            "FallBack": "0x00000000",
            "Documentations": [
              " The max number of members for the society at one time."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "bid",
          "Arguments": [
            {
              "Name": "value",
              "Type": "BalanceOf<T, I>"
            }
          ],
          "Documentations": [
            " A user outside of the society can make a bid for entry.",
            "",
            " Payment: `CandidateDeposit` will be reserved for making a bid. It is returned",
            " when the bid becomes a member, or if the bid calls `unbid`.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `value`: A one time payment the bid would like to receive when joining the society.",
            "",
            " # <weight>",
            " Key: B (len of bids), C (len of candidates), M (len of members), X (balance reserve)",
            " - Storage Reads:",
            " \t- One storage read to check for suspended candidate. O(1)",
            " \t- One storage read to check for suspended member. O(1)",
            " \t- One storage read to retrieve all current bids. O(B)",
            " \t- One storage read to retrieve all current candidates. O(C)",
            " \t- One storage read to retrieve all members. O(M)",
            " - Storage Writes:",
            " \t- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)",
            " \t- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)",
            " - Notable Computation:",
            " \t- O(B + C + log M) search to check user is not already a part of society.",
            " \t- O(log B) search to insert the new bid sorted.",
            " - External Module Operations:",
            " \t- One balance reserve operation. O(X)",
            " \t- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.",
            " - Events:",
            " \t- One event for new bid.",
            " \t- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.",
            "",
            " Total Complexity: O(M + B + C + logM + logB + X)",
            " # </weight>"
          ]
        },
        {
          "Name": "unbid",
          "Arguments": [
            {
              "Name": "pos",
              "Type": "u32"
            }
          ],
          "Documentations": [
            " A bidder can remove their bid for entry into society.",
            " By doing so, they will have their candidate deposit returned or",
            " they will unvouch their voucher.",
            "",
            " Payment: The bid deposit is unreserved if the user made a bid.",
            "",
            " The dispatch origin for this call must be _Signed_ and a bidder.",
            "",
            " Parameters:",
            " - `pos`: Position in the `Bids` vector of the bid who wants to unbid.",
            "",
            " # <weight>",
            " Key: B (len of bids), X (balance unreserve)",
            " - One storage read and write to retrieve and update the bids. O(B)",
            " - Either one unreserve balance action O(X) or one vouching storage removal. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(B + X)",
            " # </weight>"
          ]
        },
        {
          "Name": "vouch",
          "Arguments": [
            {
              "Name": "who",
              "Type": "T::AccountId"
            },
            {
              "Name": "value",
              "Type": "BalanceOf<T, I>"
            },
            {
              "Name": "tip",
              "Type": "BalanceOf<T, I>"
            }
          ],
          "Documentations": [
            " As a member, vouch for someone to join society by placing a bid on their behalf.",
            "",
            " There is no deposit required to vouch for a new bid, but a member can only vouch for",
            " one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by",
            " the suspension judgement origin, the member will be banned from vouching again.",
            "",
            " As a vouching member, you can claim a tip if the candidate is accepted. This tip will",
            " be paid as a portion of the reward the member will receive for joining the society.",
            "",
            " The dispatch origin for this call must be _Signed_ and a member.",
            "",
            " Parameters:",
            " - `who`: The user who you would like to vouch for.",
            " - `value`: The total reward to be paid between you and the candidate if they become",
            " a member in the society.",
            " - `tip`: Your cut of the total `value` payout when the candidate is inducted into",
            " the society. Tips larger than `value` will be saturated upon payout.",
            "",
            " # <weight>",
            " Key: B (len of bids), C (len of candidates), M (len of members)",
            " - Storage Reads:",
            " \t- One storage read to retrieve all members. O(M)",
            " \t- One storage read to check member is not already vouching. O(1)",
            " \t- One storage read to check for suspended candidate. O(1)",
            " \t- One storage read to check for suspended member. O(1)",
            " \t- One storage read to retrieve all current bids. O(B)",
            " \t- One storage read to retrieve all current candidates. O(C)",
            " - Storage Writes:",
            " \t- One storage write to insert vouching status to the member. O(1)",
            " \t- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)",
            " \t- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)",
            " - Notable Computation:",
            " \t- O(log M) search to check sender is a member.",
            " \t- O(B + C + log M) search to check user is not already a part of society.",
            " \t- O(log B) search to insert the new bid sorted.",
            " - External Module Operations:",
            " \t- One balance reserve operation. O(X)",
            " \t- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.",
            " - Events:",
            " \t- One event for vouch.",
            " \t- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.",
            "",
            " Total Complexity: O(M + B + C + logM + logB + X)",
            " # </weight>"
          ]
        },
        {
          "Name": "unvouch",
          "Arguments": [
            {
              "Name": "pos",
              "Type": "u32"
            }
          ],
          "Documentations": [
            " As a vouching member, unvouch a bid. This only works while vouched user is",
            " only a bidder (and not a candidate).",
            "",
            " The dispatch origin for this call must be _Signed_ and a vouching member.",
            "",
            " Parameters:",
            " - `pos`: Position in the `Bids` vector of the bid who should be unvouched.",
            "",
            " # <weight>",
            " Key: B (len of bids)",
            " - One storage read O(1) to check the signer is a vouching member.",
            " - One storage mutate to retrieve and update the bids. O(B)",
            " - One vouching storage removal. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(B)",
            " # </weight>"
          ]
        },
        {
          "Name": "vote",
          "Arguments": [
            {
              "Name": "candidate",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "approve",
              "Type": "bool"
            }
          ],
          "Documentations": [
            " As a member, vote on a candidate.",
            "",
            " The dispatch origin for this call must be _Signed_ and a member.",
            "",
            " Parameters:",
            " - `candidate`: The candidate that the member would like to bid on.",
            " - `approve`: A boolean which says if the candidate should be",
            "              approved (`true`) or rejected (`false`).",
            "",
            " # <weight>",
            " Key: C (len of candidates), M (len of members)",
            " - One storage read O(M) and O(log M) search to check user is a member.",
            " - One account lookup.",
            " - One storage read O(C) and O(C) search to check that user is a candidate.",
            " - One storage write to add vote to votes. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(M + logM + C)",
            " # </weight>"
          ]
        },
        {
          "Name": "defender_vote",
          "Arguments": [
            {
              "Name": "approve",
              "Type": "bool"
            }
          ],
          "Documentations": [
            " As a member, vote on the defender.",
            "",
            " The dispatch origin for this call must be _Signed_ and a member.",
            "",
            " Parameters:",
            " - `approve`: A boolean which says if the candidate should be",
            " approved (`true`) or rejected (`false`).",
            "",
            " # <weight>",
            " - Key: M (len of members)",
            " - One storage read O(M) and O(log M) search to check user is a member.",
            " - One storage write to add vote to votes. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(M + logM)",
            " # </weight>"
          ]
        },
        {
          "Name": "payout",
          "Arguments": [

          ],
          "Documentations": [
            " Transfer the first matured payout for the sender and remove it from the records.",
            "",
            " NOTE: This extrinsic needs to be called multiple times to claim multiple matured payouts.",
            "",
            " Payment: The member will receive a payment equal to their first matured",
            " payout to their free balance.",
            "",
            " The dispatch origin for this call must be _Signed_ and a member with",
            " payouts remaining.",
            "",
            " # <weight>",
            " Key: M (len of members), P (number of payouts for a particular member)",
            " - One storage read O(M) and O(log M) search to check signer is a member.",
            " - One storage read O(P) to get all payouts for a member.",
            " - One storage read O(1) to get the current block number.",
            " - One currency transfer call. O(X)",
            " - One storage write or removal to update the member's payouts. O(P)",
            "",
            " Total Complexity: O(M + logM + P + X)",
            " # </weight>"
          ]
        },
        {
          "Name": "found",
          "Arguments": [
            {
              "Name": "founder",
              "Type": "T::AccountId"
            },
            {
              "Name": "max_members",
              "Type": "u32"
            },
            {
              "Name": "rules",
              "Type": "Vec<u8>"
            }
          ],
          "Documentations": [
            " Found the society.",
            "",
            " This is done as a discrete action in order to allow for the",
            " module to be included into a running chain and can only be done once.",
            "",
            " The dispatch origin for this call must be from the _FounderSetOrigin_.",
            "",
            " Parameters:",
            " - `founder` - The first member and head of the newly founded society.",
            " - `max_members` - The initial max number of members for the society.",
            " - `rules` - The rules of this society concerning membership.",
            "",
            " # <weight>",
            " - Two storage mutates to set `Head` and `Founder`. O(1)",
            " - One storage write to add the first member to society. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(1)",
            " # </weight>"
          ]
        },
        {
          "Name": "unfound",
          "Arguments": [

          ],
          "Documentations": [
            " Annul the founding of the society.",
            "",
            " The dispatch origin for this call must be Signed, and the signing account must be both",
            " the `Founder` and the `Head`. This implies that it may only be done when there is one",
            " member.",
            "",
            " # <weight>",
            " - Two storage reads O(1).",
            " - Four storage removals O(1).",
            " - One event.",
            "",
            " Total Complexity: O(1)",
            " # </weight>"
          ]
        },
        {
          "Name": "judge_suspended_member",
          "Arguments": [
            {
              "Name": "who",
              "Type": "T::AccountId"
            },
            {
              "Name": "forgive",
              "Type": "bool"
            }
          ],
          "Documentations": [
            " Allow suspension judgement origin to make judgement on a suspended member.",
            "",
            " If a suspended member is forgiven, we simply add them back as a member, not affecting",
            " any of the existing storage items for that member.",
            "",
            " If a suspended member is rejected, remove all associated storage items, including",
            " their payouts, and remove any vouched bids they currently have.",
            "",
            " The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.",
            "",
            " Parameters:",
            " - `who` - The suspended member to be judged.",
            " - `forgive` - A boolean representing whether the suspension judgement origin",
            "               forgives (`true`) or rejects (`false`) a suspended member.",
            "",
            " # <weight>",
            " Key: B (len of bids), M (len of members)",
            " - One storage read to check `who` is a suspended member. O(1)",
            " - Up to one storage write O(M) with O(log M) binary search to add a member back to society.",
            " - Up to 3 storage removals O(1) to clean up a removed member.",
            " - Up to one storage write O(B) with O(B) search to remove vouched bid from bids.",
            " - Up to one additional event if unvouch takes place.",
            " - One storage removal. O(1)",
            " - One event for the judgement.",
            "",
            " Total Complexity: O(M + logM + B)",
            " # </weight>"
          ]
        },
        {
          "Name": "judge_suspended_candidate",
          "Arguments": [
            {
              "Name": "who",
              "Type": "T::AccountId"
            },
            {
              "Name": "judgement",
              "Type": "Judgement"
            }
          ],
          "Documentations": [
            " Allow suspended judgement origin to make judgement on a suspended candidate.",
            "",
            " If the judgement is `Approve`, we add them to society as a member with the appropriate",
            " payment for joining society.",
            "",
            " If the judgement is `Reject`, we either slash the deposit of the bid, giving it back",
            " to the society treasury, or we ban the voucher from vouching again.",
            "",
            " If the judgement is `Rebid`, we put the candidate back in the bid pool and let them go",
            " through the induction process again.",
            "",
            " The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.",
            "",
            " Parameters:",
            " - `who` - The suspended candidate to be judged.",
            " - `judgement` - `Approve`, `Reject`, or `Rebid`.",
            "",
            " # <weight>",
            " Key: B (len of bids), M (len of members), X (balance action)",
            " - One storage read to check `who` is a suspended candidate.",
            " - One storage removal of the suspended candidate.",
            " - Approve Logic",
            " \t- One storage read to get the available pot to pay users with. O(1)",
            " \t- One storage write to update the available pot. O(1)",
            " \t- One storage read to get the current block number. O(1)",
            " \t- One storage read to get all members. O(M)",
            " \t- Up to one unreserve currency action.",
            " \t- Up to two new storage writes to payouts.",
            " \t- Up to one storage write with O(log M) binary search to add a member to society.",
            " - Reject Logic",
            " \t- Up to one repatriate reserved currency action. O(X)",
            " \t- Up to one storage write to ban the vouching member from vouching again.",
            " - Rebid Logic",
            " \t- Storage mutate with O(log B) binary search to place the user back into bids.",
            " - Up to one additional event if unvouch takes place.",
            " - One storage removal.",
            " - One event for the judgement.",
            "",
            " Total Complexity: O(M + logM + B + X)",
            " # </weight>"
          ]
        },
        {
          "Name": "set_max_members",
          "Arguments": [
            {
              "Name": "max",
              "Type": "u32"
            }
          ],
          "Documentations": [
            " Allows root origin to change the maximum number of members in society.",
            " Max membership count must be greater than 1.",
            "",
            " The dispatch origin for this call must be from _ROOT_.",
            "",
            " Parameters:",
            " - `max` - The maximum number of members for the society.",
            "",
            " # <weight>",
            " - One storage write to update the max. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(1)",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " The society is founded by the given identity. \\[founder\\]"
          ],
          "Name": "Founded",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A membership bid just happened. The given account is the candidate's ID and their offer",
            " is the second. \\[candidate_id, offer\\]"
          ],
          "Name": "Bid",
          "EventArgs": [
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " A membership bid just happened by vouching. The given account is the candidate's ID and",
            " their offer is the second. The vouching party is the third. \\[candidate_id, offer, vouching\\]"
          ],
          "Name": "Vouch",
          "EventArgs": [
            "AccountId",
            "Balance",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A \\[candidate\\] was dropped (due to an excess of bids in the system)."
          ],
          "Name": "AutoUnbid",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A \\[candidate\\] was dropped (by their request)."
          ],
          "Name": "Unbid",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A \\[candidate\\] was dropped (by request of who vouched for them)."
          ],
          "Name": "Unvouch",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A group of candidates have been inducted. The batch's primary is the first value, the",
            " batch in full is the second. \\[primary, candidates\\]"
          ],
          "Name": "Inducted",
          "EventArgs": [
            "AccountId",
            "Vec<AccountId>"
          ]
        },
        {
          "Documentations": [
            " A suspended member has been judged. \\[who, judged\\]"
          ],
          "Name": "SuspendedMemberJudgement",
          "EventArgs": [
            "AccountId",
            "bool"
          ]
        },
        {
          "Documentations": [
            " A \\[candidate\\] has been suspended"
          ],
          "Name": "CandidateSuspended",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A \\[member\\] has been suspended"
          ],
          "Name": "MemberSuspended",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A \\[member\\] has been challenged"
          ],
          "Name": "Challenged",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A vote has been placed \\[candidate, voter, vote\\]"
          ],
          "Name": "Vote",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "bool"
          ]
        },
        {
          "Documentations": [
            " A vote has been placed for a defending member \\[voter, vote\\]"
          ],
          "Name": "DefenderVote",
          "EventArgs": [
            "AccountId",
            "bool"
          ]
        },
        {
          "Documentations": [
            " A new \\[max\\] member count has been set"
          ],
          "Name": "NewMaxMembers",
          "EventArgs": [
            "u32"
          ]
        },
        {
          "Documentations": [
            " Society is unfounded. \\[founder\\]"
          ],
          "Name": "Unfounded",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " Some funds were deposited into the society account. \\[value\\]"
          ],
          "Name": "Deposit",
          "EventArgs": [
            "Balance"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "CandidateDeposit",
          "Type": "BalanceOf<T, I>",
          "Value": "0x0080C6A47E8D03000000000000000000",
          "Documentations": [
            " The minimum amount of a deposit required for a bid to be made."
          ]
        },
        {
          "Name": "WrongSideDeduction",
          "Type": "BalanceOf<T, I>",
          "Value": "0x0080F420E6B500000000000000000000",
          "Documentations": [
            " The amount of the unpaid reward that gets deducted in the case that either a skeptic",
            " doesn't vote or someone votes in the wrong way."
          ]
        },
        {
          "Name": "MaxStrikes",
          "Type": "u32",
          "Value": "0x0A000000",
          "Documentations": [
            " The number of times a member may vote the wrong way (or not at all, when they are a skeptic)",
            " before they become suspended."
          ]
        },
        {
          "Name": "PeriodSpend",
          "Type": "BalanceOf<T, I>",
          "Value": "0x0000C52EBCA2B1000000000000000000",
          "Documentations": [
            " The amount of incentive paid within each period. Doesn't include VoterTip."
          ]
        },
        {
          "Name": "RotationPeriod",
          "Type": "T::BlockNumber",
          "Value": "0x00770100",
          "Documentations": [
            " The number of blocks between candidate/membership rotation periods."
          ]
        },
        {
          "Name": "ChallengePeriod",
          "Type": "T::BlockNumber",
          "Value": "0x80130300",
          "Documentations": [
            " The number of blocks between membership challenges."
          ]
        },
        {
          "Name": "ModuleId",
          "Type": "ModuleId",
          "Value": "0x70792F736F636965",
          "Documentations": [
            " The societies's module id"
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " An incorrect position was provided."
          ],
          "Name": "BadPosition"
        },
        {
          "Documentations": [
            " User is not a member."
          ],
          "Name": "NotMember"
        },
        {
          "Documentations": [
            " User is already a member."
          ],
          "Name": "AlreadyMember"
        },
        {
          "Documentations": [
            " User is suspended."
          ],
          "Name": "Suspended"
        },
        {
          "Documentations": [
            " User is not suspended."
          ],
          "Name": "NotSuspended"
        },
        {
          "Documentations": [
            " Nothing to payout."
          ],
          "Name": "NoPayout"
        },
        {
          "Documentations": [
            " Society already founded."
          ],
          "Name": "AlreadyFounded"
        },
        {
          "Documentations": [
            " Not enough in pot to accept candidate."
          ],
          "Name": "InsufficientPot"
        },
        {
          "Documentations": [
            " Member is already vouching or banned from vouching again."
          ],
          "Name": "AlreadyVouching"
        },
        {
          "Documentations": [
            " Member is not vouching."
          ],
          "Name": "NotVouching"
        },
        {
          "Documentations": [
            " Cannot remove the head of the chain."
          ],
          "Name": "Head"
        },
        {
          "Documentations": [
            " Cannot remove the founder."
          ],
          "Name": "Founder"
        },
        {
          "Documentations": [
            " User has already made a bid."
          ],
          "Name": "AlreadyBid"
        },
        {
          "Documentations": [
            " User is already a candidate."
          ],
          "Name": "AlreadyCandidate"
        },
        {
          "Documentations": [
            " User is not a candidate."
          ],
          "Name": "NotCandidate"
        },
        {
          "Documentations": [
            " Too many members in the society."
          ],
          "Name": "MaxMembers"
        },
        {
          "Documentations": [
            " The caller is not the founder."
          ],
          "Name": "NotFounder"
        },
        {
          "Documentations": [
            " The caller is not the head."
          ],
          "Name": "NotHead"
        }
      ]
    },
    {
      "Name": "Recovery",
      "Index": 34,
      "Storage": {
        "Prefix": "Recovery",
        "Items": [
          {
            "Name": "Recoverable",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "RecoveryConfig<T::BlockNumber, BalanceOf<T>, T::AccountId>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The set of recoverable accounts and their recovery configuration."
            ]
          },
          {
            "Name": "ActiveRecoveries",
            "Modifier": "Optional",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "Twox64Concat",
              "Key1": "T::AccountId",
              "Key2": "T::AccountId",
              "Value": "ActiveRecovery<T::BlockNumber, BalanceOf<T>, T::AccountId>",
              "IsLinked": true
            },
            "FallBack": "0x00",
            "Documentations": [
              " Active recovery attempts.",
              "",
              " First account is the account to be recovered, and the second account",
              " is the user trying to recover the account."
            ]
          },
          {
            "Name": "Proxy",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AccountId",
              "Key2": null,
              "Value": "T::AccountId",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " The list of allowed proxy accounts.",
              "",
              " Map from the user who can access it to the recovered account."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "as_recovered",
          "Arguments": [
            {
              "Name": "account",
              "Type": "T::AccountId"
            },
            {
              "Name": "call",
              "Type": "Box<<T as Config>::Call>"
            }
          ],
          "Documentations": [
            " Send a call through a recovered account.",
            "",
            " The dispatch origin for this call must be _Signed_ and registered to",
            " be able to make calls on behalf of the recovered account.",
            "",
            " Parameters:",
            " - `account`: The recovered account you want to make a call on-behalf-of.",
            " - `call`: The call you want to make with the recovered account.",
            "",
            " # <weight>",
            " - The weight of the `call` + 10,000.",
            " - One storage lookup to check account is recovered by `who`. O(1)",
            " # </weight>"
          ]
        },
        {
          "Name": "set_recovered",
          "Arguments": [
            {
              "Name": "lost",
              "Type": "T::AccountId"
            },
            {
              "Name": "rescuer",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Allow ROOT to bypass the recovery process and set an a rescuer account",
            " for a lost account directly.",
            "",
            " The dispatch origin for this call must be _ROOT_.",
            "",
            " Parameters:",
            " - `lost`: The \"lost account\" to be recovered.",
            " - `rescuer`: The \"rescuer account\" which can call as the lost account.",
            "",
            " # <weight>",
            " - One storage write O(1)",
            " - One event",
            " # </weight>"
          ]
        },
        {
          "Name": "create_recovery",
          "Arguments": [
            {
              "Name": "friends",
              "Type": "Vec<T::AccountId>"
            },
            {
              "Name": "threshold",
              "Type": "u16"
            },
            {
              "Name": "delay_period",
              "Type": "T::BlockNumber"
            }
          ],
          "Documentations": [
            " Create a recovery configuration for your account. This makes your account recoverable.",
            "",
            " Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance",
            " will be reserved for storing the recovery configuration. This deposit is returned",
            " in full when the user calls `remove_recovery`.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `friends`: A list of friends you trust to vouch for recovery attempts.",
            "   Should be ordered and contain no duplicate values.",
            " - `threshold`: The number of friends that must vouch for a recovery attempt",
            "   before the account can be recovered. Should be less than or equal to",
            "   the length of the list of friends.",
            " - `delay_period`: The number of blocks after a recovery attempt is initialized",
            "   that needs to pass before the account can be recovered.",
            "",
            " # <weight>",
            " - Key: F (len of friends)",
            " - One storage read to check that account is not already recoverable. O(1).",
            " - A check that the friends list is sorted and unique. O(F)",
            " - One currency reserve operation. O(X)",
            " - One storage write. O(1). Codec O(F).",
            " - One event.",
            "",
            " Total Complexity: O(F + X)",
            " # </weight>"
          ]
        },
        {
          "Name": "initiate_recovery",
          "Arguments": [
            {
              "Name": "account",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Initiate the process for recovering a recoverable account.",
            "",
            " Payment: `RecoveryDeposit` balance will be reserved for initiating the",
            " recovery process. This deposit will always be repatriated to the account",
            " trying to be recovered. See `close_recovery`.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `account`: The lost account that you want to recover. This account",
            "   needs to be recoverable (i.e. have a recovery configuration).",
            "",
            " # <weight>",
            " - One storage read to check that account is recoverable. O(F)",
            " - One storage read to check that this recovery process hasn't already started. O(1)",
            " - One currency reserve operation. O(X)",
            " - One storage read to get the current block number. O(1)",
            " - One storage write. O(1).",
            " - One event.",
            "",
            " Total Complexity: O(F + X)",
            " # </weight>"
          ]
        },
        {
          "Name": "vouch_recovery",
          "Arguments": [
            {
              "Name": "lost",
              "Type": "T::AccountId"
            },
            {
              "Name": "rescuer",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Allow a \"friend\" of a recoverable account to vouch for an active recovery",
            " process for that account.",
            "",
            " The dispatch origin for this call must be _Signed_ and must be a \"friend\"",
            " for the recoverable account.",
            "",
            " Parameters:",
            " - `lost`: The lost account that you want to recover.",
            " - `rescuer`: The account trying to rescue the lost account that you",
            "   want to vouch for.",
            "",
            " The combination of these two parameters must point to an active recovery",
            " process.",
            "",
            " # <weight>",
            " Key: F (len of friends in config), V (len of vouching friends)",
            " - One storage read to get the recovery configuration. O(1), Codec O(F)",
            " - One storage read to get the active recovery process. O(1), Codec O(V)",
            " - One binary search to confirm caller is a friend. O(logF)",
            " - One binary search to confirm caller has not already vouched. O(logV)",
            " - One storage write. O(1), Codec O(V).",
            " - One event.",
            "",
            " Total Complexity: O(F + logF + V + logV)",
            " # </weight>"
          ]
        },
        {
          "Name": "claim_recovery",
          "Arguments": [
            {
              "Name": "account",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Allow a successful rescuer to claim their recovered account.",
            "",
            " The dispatch origin for this call must be _Signed_ and must be a \"rescuer\"",
            " who has successfully completed the account recovery process: collected",
            " `threshold` or more vouches, waited `delay_period` blocks since initiation.",
            "",
            " Parameters:",
            " - `account`: The lost account that you want to claim has been successfully",
            "   recovered by you.",
            "",
            " # <weight>",
            " Key: F (len of friends in config), V (len of vouching friends)",
            " - One storage read to get the recovery configuration. O(1), Codec O(F)",
            " - One storage read to get the active recovery process. O(1), Codec O(V)",
            " - One storage read to get the current block number. O(1)",
            " - One storage write. O(1), Codec O(V).",
            " - One event.",
            "",
            " Total Complexity: O(F + V)",
            " # </weight>"
          ]
        },
        {
          "Name": "close_recovery",
          "Arguments": [
            {
              "Name": "rescuer",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " As the controller of a recoverable account, close an active recovery",
            " process for your account.",
            "",
            " Payment: By calling this function, the recoverable account will receive",
            " the recovery deposit `RecoveryDeposit` placed by the rescuer.",
            "",
            " The dispatch origin for this call must be _Signed_ and must be a",
            " recoverable account with an active recovery process for it.",
            "",
            " Parameters:",
            " - `rescuer`: The account trying to rescue this recoverable account.",
            "",
            " # <weight>",
            " Key: V (len of vouching friends)",
            " - One storage read/remove to get the active recovery process. O(1), Codec O(V)",
            " - One balance call to repatriate reserved. O(X)",
            " - One event.",
            "",
            " Total Complexity: O(V + X)",
            " # </weight>"
          ]
        },
        {
          "Name": "remove_recovery",
          "Arguments": [

          ],
          "Documentations": [
            " Remove the recovery process for your account. Recovered accounts are still accessible.",
            "",
            " NOTE: The user must make sure to call `close_recovery` on all active",
            " recovery attempts before calling this function else it will fail.",
            "",
            " Payment: By calling this function the recoverable account will unreserve",
            " their recovery configuration deposit.",
            " (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)",
            "",
            " The dispatch origin for this call must be _Signed_ and must be a",
            " recoverable account (i.e. has a recovery configuration).",
            "",
            " # <weight>",
            " Key: F (len of friends)",
            " - One storage read to get the prefix iterator for active recoveries. O(1)",
            " - One storage read/remove to get the recovery configuration. O(1), Codec O(F)",
            " - One balance call to unreserved. O(X)",
            " - One event.",
            "",
            " Total Complexity: O(F + X)",
            " # </weight>"
          ]
        },
        {
          "Name": "cancel_recovered",
          "Arguments": [
            {
              "Name": "account",
              "Type": "T::AccountId"
            }
          ],
          "Documentations": [
            " Cancel the ability to use `as_recovered` for `account`.",
            "",
            " The dispatch origin for this call must be _Signed_ and registered to",
            " be able to make calls on behalf of the recovered account.",
            "",
            " Parameters:",
            " - `account`: The recovered account you are able to call on-behalf-of.",
            "",
            " # <weight>",
            " - One storage mutation to check account is recovered by `who`. O(1)",
            " # </weight>"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " A recovery process has been set up for an \\[account\\]."
          ],
          "Name": "RecoveryCreated",
          "EventArgs": [
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A recovery process has been initiated for lost account by rescuer account.",
            " \\[lost, rescuer\\]"
          ],
          "Name": "RecoveryInitiated",
          "EventArgs": [
            "AccountId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A recovery process for lost account by rescuer account has been vouched for by sender.",
            " \\[lost, rescuer, sender\\]"
          ],
          "Name": "RecoveryVouched",
          "EventArgs": [
            "AccountId",
            "AccountId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A recovery process for lost account by rescuer account has been closed.",
            " \\[lost, rescuer\\]"
          ],
          "Name": "RecoveryClosed",
          "EventArgs": [
            "AccountId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " Lost account has been successfully recovered by rescuer account.",
            " \\[lost, rescuer\\]"
          ],
          "Name": "AccountRecovered",
          "EventArgs": [
            "AccountId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " A recovery process has been removed for an \\[account\\]."
          ],
          "Name": "RecoveryRemoved",
          "EventArgs": [
            "AccountId"
          ]
        }
      ],
      "Consts": [
        {
          "Name": "ConfigDepositBase",
          "Type": "BalanceOf<T>",
          "Value": "0x00406352BFC601000000000000000000",
          "Documentations": [
            " The base amount of currency needed to reserve for creating a recovery configuration."
          ]
        },
        {
          "Name": "FriendDepositFactor",
          "Type": "BalanceOf<T>",
          "Value": "0x00203D88792D00000000000000000000",
          "Documentations": [
            " The amount of currency needed per additional user when creating a recovery configuration."
          ]
        },
        {
          "Name": "MaxFriends",
          "Type": "u16",
          "Value": "0x0900",
          "Documentations": [
            " The maximum amount of friends allowed in a recovery configuration."
          ]
        },
        {
          "Name": "RecoveryDeposit",
          "Type": "BalanceOf<T>",
          "Value": "0x00406352BFC601000000000000000000",
          "Documentations": [
            " The base amount of currency needed to reserve for starting a recovery."
          ]
        }
      ],
      "Errors": [
        {
          "Documentations": [
            " User is not allowed to make a call on behalf of this account"
          ],
          "Name": "NotAllowed"
        },
        {
          "Documentations": [
            " Threshold must be greater than zero"
          ],
          "Name": "ZeroThreshold"
        },
        {
          "Documentations": [
            " Friends list must be greater than zero and threshold"
          ],
          "Name": "NotEnoughFriends"
        },
        {
          "Documentations": [
            " Friends list must be less than max friends"
          ],
          "Name": "MaxFriends"
        },
        {
          "Documentations": [
            " Friends list must be sorted and free of duplicates"
          ],
          "Name": "NotSorted"
        },
        {
          "Documentations": [
            " This account is not set up for recovery"
          ],
          "Name": "NotRecoverable"
        },
        {
          "Documentations": [
            " This account is already set up for recovery"
          ],
          "Name": "AlreadyRecoverable"
        },
        {
          "Documentations": [
            " A recovery process has already started for this account"
          ],
          "Name": "AlreadyStarted"
        },
        {
          "Documentations": [
            " A recovery process has not started for this rescuer"
          ],
          "Name": "NotStarted"
        },
        {
          "Documentations": [
            " This account is not a friend who can vouch"
          ],
          "Name": "NotFriend"
        },
        {
          "Documentations": [
            " The friend must wait until the delay period to vouch for this recovery"
          ],
          "Name": "DelayPeriod"
        },
        {
          "Documentations": [
            " This user has already vouched for this recovery"
          ],
          "Name": "AlreadyVouched"
        },
        {
          "Documentations": [
            " The threshold for recovering this account has not been met"
          ],
          "Name": "Threshold"
        },
        {
          "Documentations": [
            " There are still active recovery attempts that need to be closed"
          ],
          "Name": "StillActive"
        },
        {
          "Documentations": [
            " There was an overflow in a calculation"
          ],
          "Name": "Overflow"
        },
        {
          "Documentations": [
            " This account is already set up for recovery"
          ],
          "Name": "AlreadyProxy"
        },
        {
          "Documentations": [
            " Some internal state is broken."
          ],
          "Name": "BadState"
        }
      ]
    },
    {
      "Name": "Assets",
      "Index": 35,
      "Storage": {
        "Prefix": "Assets",
        "Items": [
          {
            "Name": "Asset",
            "Modifier": "Optional",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AssetId",
              "Key2": null,
              "Value": "AssetDetails<T::Balance, T::AccountId, BalanceOf<T>>",
              "IsLinked": false
            },
            "FallBack": "0x00",
            "Documentations": [
              " Details of an asset."
            ]
          },
          {
            "Name": "Account",
            "Modifier": "Default",
            "Type": "DoubleMap",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AssetId",
              "Key2": "T::AccountId",
              "Value": "AssetBalance<T::Balance>",
              "IsLinked": true
            },
            "FallBack": "0x00000000000000000000",
            "Documentations": [
              " The number of units of assets held by any given account."
            ]
          },
          {
            "Name": "Metadata",
            "Modifier": "Default",
            "Type": "Map",
            "Function": {
              "Hasher": "BlakeTwo128Concat",
              "Key1": "T::AssetId",
              "Key2": null,
              "Value": "AssetMetadata<BalanceOf<T>>",
              "IsLinked": false
            },
            "FallBack": "0x00000000000000000000000000000000000000",
            "Documentations": [
              " Metadata of an asset."
            ]
          }
        ]
      },
      "Calls": [
        {
          "Name": "create",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "admin",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "max_zombies",
              "Type": "u32"
            },
            {
              "Name": "min_balance",
              "Type": "T::Balance"
            }
          ],
          "Documentations": [
            " Issue a new class of fungible assets from a public origin.",
            "",
            " This new asset class has no assets initially.",
            "",
            " The origin must be Signed and the sender must have sufficient funds free.",
            "",
            " Funds of sender are reserved according to the formula:",
            " `AssetDepositBase + AssetDepositPerZombie * max_zombies`.",
            "",
            " Parameters:",
            " - `id`: The identifier of the new asset. This must not be currently in use to identify",
            " an existing asset.",
            " - `owner`: The owner of this class of assets. The owner has full superuser permissions",
            " over this asset, but may later change and configure the permissions using `transfer_ownership`",
            " and `set_team`.",
            " - `max_zombies`: The total number of accounts which may hold assets in this class yet",
            " have no existential deposit.",
            " - `min_balance`: The minimum balance of this new asset that any single account must",
            " have. If an account's balance is reduced below this, then it collapses to zero.",
            "",
            " Emits `Created` event when successful.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "force_create",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "owner",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "max_zombies",
              "Type": "Compact<u32>"
            },
            {
              "Name": "min_balance",
              "Type": "Compact<T::Balance>"
            }
          ],
          "Documentations": [
            " Issue a new class of fungible assets from a privileged origin.",
            "",
            " This new asset class has no assets initially.",
            "",
            " The origin must conform to `ForceOrigin`.",
            "",
            " Unlike `create`, no funds are reserved.",
            "",
            " - `id`: The identifier of the new asset. This must not be currently in use to identify",
            " an existing asset.",
            " - `owner`: The owner of this class of assets. The owner has full superuser permissions",
            " over this asset, but may later change and configure the permissions using `transfer_ownership`",
            " and `set_team`.",
            " - `max_zombies`: The total number of accounts which may hold assets in this class yet",
            " have no existential deposit.",
            " - `min_balance`: The minimum balance of this new asset that any single account must",
            " have. If an account's balance is reduced below this, then it collapses to zero.",
            "",
            " Emits `ForceCreated` event when successful.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "destroy",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "zombies_witness",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Destroy a class of fungible assets owned by the sender.",
            "",
            " The origin must be Signed and the sender must be the owner of the asset `id`.",
            "",
            " - `id`: The identifier of the asset to be destroyed. This must identify an existing",
            " asset.",
            "",
            " Emits `Destroyed` event when successful.",
            "",
            " Weight: `O(z)` where `z` is the number of zombie accounts."
          ]
        },
        {
          "Name": "force_destroy",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "zombies_witness",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Destroy a class of fungible assets.",
            "",
            " The origin must conform to `ForceOrigin`.",
            "",
            " - `id`: The identifier of the asset to be destroyed. This must identify an existing",
            " asset.",
            "",
            " Emits `Destroyed` event when successful.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "mint",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "beneficiary",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "amount",
              "Type": "Compact<T::Balance>"
            }
          ],
          "Documentations": [
            " Mint assets of a particular class.",
            "",
            " The origin must be Signed and the sender must be the Issuer of the asset `id`.",
            "",
            " - `id`: The identifier of the asset to have some amount minted.",
            " - `beneficiary`: The account to be credited with the minted assets.",
            " - `amount`: The amount of the asset to be minted.",
            "",
            " Emits `Destroyed` event when successful.",
            "",
            " Weight: `O(1)`",
            " Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`."
          ]
        },
        {
          "Name": "burn",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "who",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "amount",
              "Type": "Compact<T::Balance>"
            }
          ],
          "Documentations": [
            " Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.",
            "",
            " Origin must be Signed and the sender should be the Manager of the asset `id`.",
            "",
            " Bails with `BalanceZero` if the `who` is already dead.",
            "",
            " - `id`: The identifier of the asset to have some amount burned.",
            " - `who`: The account to be debited from.",
            " - `amount`: The maximum amount by which `who`'s balance should be reduced.",
            "",
            " Emits `Burned` with the actual amount burned. If this takes the balance to below the",
            " minimum for the asset, then the amount burned is increased to take it to zero.",
            "",
            " Weight: `O(1)`",
            " Modes: Post-existence of `who`; Pre & post Zombie-status of `who`."
          ]
        },
        {
          "Name": "transfer",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "target",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "amount",
              "Type": "Compact<T::Balance>"
            }
          ],
          "Documentations": [
            " Move some assets from the sender account to another.",
            "",
            " Origin must be Signed.",
            "",
            " - `id`: The identifier of the asset to have some amount transferred.",
            " - `target`: The account to be credited.",
            " - `amount`: The amount by which the sender's balance of assets should be reduced and",
            " `target`'s balance increased. The amount actually transferred may be slightly greater in",
            " the case that the transfer would otherwise take the sender balance above zero but below",
            " the minimum balance. Must be greater than zero.",
            "",
            " Emits `Transferred` with the actual amount transferred. If this takes the source balance",
            " to below the minimum for the asset, then the amount transferred is increased to take it",
            " to zero.",
            "",
            " Weight: `O(1)`",
            " Modes: Pre-existence of `target`; Post-existence of sender; Prior & post zombie-status",
            " of sender; Account pre-existence of `target`."
          ]
        },
        {
          "Name": "force_transfer",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "source",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "dest",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "amount",
              "Type": "Compact<T::Balance>"
            }
          ],
          "Documentations": [
            " Move some assets from one account to another.",
            "",
            " Origin must be Signed and the sender should be the Admin of the asset `id`.",
            "",
            " - `id`: The identifier of the asset to have some amount transferred.",
            " - `source`: The account to be debited.",
            " - `dest`: The account to be credited.",
            " - `amount`: The amount by which the `source`'s balance of assets should be reduced and",
            " `dest`'s balance increased. The amount actually transferred may be slightly greater in",
            " the case that the transfer would otherwise take the `source` balance above zero but",
            " below the minimum balance. Must be greater than zero.",
            "",
            " Emits `Transferred` with the actual amount transferred. If this takes the source balance",
            " to below the minimum for the asset, then the amount transferred is increased to take it",
            " to zero.",
            "",
            " Weight: `O(1)`",
            " Modes: Pre-existence of `dest`; Post-existence of `source`; Prior & post zombie-status",
            " of `source`; Account pre-existence of `dest`."
          ]
        },
        {
          "Name": "freeze",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "who",
              "Type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "Documentations": [
            " Disallow further unprivileged transfers from an account.",
            "",
            " Origin must be Signed and the sender should be the Freezer of the asset `id`.",
            "",
            " - `id`: The identifier of the asset to be frozen.",
            " - `who`: The account to be frozen.",
            "",
            " Emits `Frozen`.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "thaw",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "who",
              "Type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "Documentations": [
            " Allow unprivileged transfers from an account again.",
            "",
            " Origin must be Signed and the sender should be the Admin of the asset `id`.",
            "",
            " - `id`: The identifier of the asset to be frozen.",
            " - `who`: The account to be unfrozen.",
            "",
            " Emits `Thawed`.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "freeze_asset",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            }
          ],
          "Documentations": [
            " Disallow further unprivileged transfers for the asset class.",
            "",
            " Origin must be Signed and the sender should be the Freezer of the asset `id`.",
            "",
            " - `id`: The identifier of the asset to be frozen.",
            "",
            " Emits `Frozen`.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "thaw_asset",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            }
          ],
          "Documentations": [
            " Allow unprivileged transfers for the asset again.",
            "",
            " Origin must be Signed and the sender should be the Admin of the asset `id`.",
            "",
            " - `id`: The identifier of the asset to be frozen.",
            "",
            " Emits `Thawed`.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "transfer_ownership",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "owner",
              "Type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "Documentations": [
            " Change the Owner of an asset.",
            "",
            " Origin must be Signed and the sender should be the Owner of the asset `id`.",
            "",
            " - `id`: The identifier of the asset to be frozen.",
            " - `owner`: The new Owner of this asset.",
            "",
            " Emits `OwnerChanged`.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "set_team",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "issuer",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "admin",
              "Type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "Name": "freezer",
              "Type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "Documentations": [
            " Change the Issuer, Admin and Freezer of an asset.",
            "",
            " Origin must be Signed and the sender should be the Owner of the asset `id`.",
            "",
            " - `id`: The identifier of the asset to be frozen.",
            " - `issuer`: The new Issuer of this asset.",
            " - `admin`: The new Admin of this asset.",
            " - `freezer`: The new Freezer of this asset.",
            "",
            " Emits `TeamChanged`.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "set_max_zombies",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "max_zombies",
              "Type": "Compact<u32>"
            }
          ],
          "Documentations": [
            " Set the maximum number of zombie accounts for an asset.",
            "",
            " Origin must be Signed and the sender should be the Owner of the asset `id`.",
            "",
            " Funds of sender are reserved according to the formula:",
            " `AssetDepositBase + AssetDepositPerZombie * max_zombies` taking into account",
            " any already reserved funds.",
            "",
            " - `id`: The identifier of the asset to update zombie count.",
            " - `max_zombies`: The new number of zombies allowed for this asset.",
            "",
            " Emits `MaxZombiesChanged`.",
            "",
            " Weight: `O(1)`"
          ]
        },
        {
          "Name": "set_metadata",
          "Arguments": [
            {
              "Name": "id",
              "Type": "Compact<T::AssetId>"
            },
            {
              "Name": "name",
              "Type": "Vec<u8>"
            },
            {
              "Name": "symbol",
              "Type": "Vec<u8>"
            },
            {
              "Name": "decimals",
              "Type": "u8"
            }
          ],
          "Documentations": [
            " Set the metadata for an asset.",
            "",
            " NOTE: There is no `unset_metadata` call. Simply pass an empty name, symbol,",
            " and 0 decimals to this function to remove the metadata of an asset and",
            " return your deposit.",
            "",
            " Origin must be Signed and the sender should be the Owner of the asset `id`.",
            "",
            " Funds of sender are reserved according to the formula:",
            " `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into",
            " account any already reserved funds.",
            "",
            " - `id`: The identifier of the asset to update.",
            " - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.",
            " - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.",
            " - `decimals`: The number of decimals this asset uses to represent one unit.",
            "",
            " Emits `MaxZombiesChanged`.",
            "",
            " Weight: `O(1)`"
          ]
        }
      ],
      "Events": [
        {
          "Documentations": [
            " Some asset class was created. \\[asset_id, creator, owner\\]"
          ],
          "Name": "Created",
          "EventArgs": [
            "AssetId",
            "AccountId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " Some assets were issued. \\[asset_id, owner, total_supply\\]"
          ],
          "Name": "Issued",
          "EventArgs": [
            "AssetId",
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Some assets were transferred. \\[asset_id, from, to, amount\\]"
          ],
          "Name": "Transferred",
          "EventArgs": [
            "AssetId",
            "AccountId",
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Some assets were destroyed. \\[asset_id, owner, balance\\]"
          ],
          "Name": "Burned",
          "EventArgs": [
            "AssetId",
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " The management team changed \\[asset_id, issuer, admin, freezer\\]"
          ],
          "Name": "TeamChanged",
          "EventArgs": [
            "AssetId",
            "AccountId",
            "AccountId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " The owner changed \\[asset_id, owner\\]"
          ],
          "Name": "OwnerChanged",
          "EventArgs": [
            "AssetId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " Some assets was transferred by an admin. \\[asset_id, from, to, amount\\]"
          ],
          "Name": "ForceTransferred",
          "EventArgs": [
            "AssetId",
            "AccountId",
            "AccountId",
            "Balance"
          ]
        },
        {
          "Documentations": [
            " Some account `who` was frozen. \\[asset_id, who\\]"
          ],
          "Name": "Frozen",
          "EventArgs": [
            "AssetId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " Some account `who` was thawed. \\[asset_id, who\\]"
          ],
          "Name": "Thawed",
          "EventArgs": [
            "AssetId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " Some asset `asset_id` was frozen. \\[asset_id\\]"
          ],
          "Name": "AssetFrozen",
          "EventArgs": [
            "AssetId"
          ]
        },
        {
          "Documentations": [
            " Some asset `asset_id` was thawed. \\[asset_id\\]"
          ],
          "Name": "AssetThawed",
          "EventArgs": [
            "AssetId"
          ]
        },
        {
          "Documentations": [
            " An asset class was destroyed."
          ],
          "Name": "Destroyed",
          "EventArgs": [
            "AssetId"
          ]
        },
        {
          "Documentations": [
            " Some asset class was force-created. \\[asset_id, owner\\]"
          ],
          "Name": "ForceCreated",
          "EventArgs": [
            "AssetId",
            "AccountId"
          ]
        },
        {
          "Documentations": [
            " The maximum amount of zombies allowed has changed. \\[asset_id, max_zombies\\]"
          ],
          "Name": "MaxZombiesChanged",
          "EventArgs": [
            "AssetId",
            "u32"
          ]
        },
        {
          "Documentations": [
            " New metadata has been set for an asset. \\[asset_id, name, symbol, decimals\\]"
          ],
          "Name": "MetadataSet",
          "EventArgs": [
            "AssetId",
            "Vec<u8>",
            "Vec<u8>",
            "u8"
          ]
        }
      ],
      "Consts": [

      ],
      "Errors": [
        {
          "Documentations": [
            " Transfer amount should be non-zero."
          ],
          "Name": "AmountZero"
        },
        {
          "Documentations": [
            " Account balance must be greater than or equal to the transfer amount."
          ],
          "Name": "BalanceLow"
        },
        {
          "Documentations": [
            " Balance should be non-zero."
          ],
          "Name": "BalanceZero"
        },
        {
          "Documentations": [
            " The signing account has no permission to do the operation."
          ],
          "Name": "NoPermission"
        },
        {
          "Documentations": [
            " The given asset ID is unknown."
          ],
          "Name": "Unknown"
        },
        {
          "Documentations": [
            " The origin account is frozen."
          ],
          "Name": "Frozen"
        },
        {
          "Documentations": [
            " The asset ID is already taken."
          ],
          "Name": "InUse"
        },
        {
          "Documentations": [
            " Too many zombie accounts in use."
          ],
          "Name": "TooManyZombies"
        },
        {
          "Documentations": [
            " Attempt to destroy an asset class when non-zombie, reference-bearing accounts exist."
          ],
          "Name": "RefsLeft"
        },
        {
          "Documentations": [
            " Invalid witness data given."
          ],
          "Name": "BadWitness"
        },
        {
          "Documentations": [
            " Minimum balance should be non-zero."
          ],
          "Name": "MinBalanceZero"
        },
        {
          "Documentations": [
            " A mint operation lead to an overflow."
          ],
          "Name": "Overflow"
        },
        {
          "Documentations": [
            " Some internal state is broken."
          ],
          "Name": "BadState"
        },
        {
          "Documentations": [
            " Invalid metadata given."
          ],
          "Name": "BadMetadata"
        }
      ]
    }
  ],
  "ExtrinsicExtensions": [
    "CheckSpecVersion",
    "CheckTxVersion",
    "CheckGenesis",
    "CheckMortality",
    "CheckNonce",
    "CheckWeight",
    "ChargeTransactionPayment"
  ]
}